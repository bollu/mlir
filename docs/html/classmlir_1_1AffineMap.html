<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: mlir::AffineMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1AffineMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::AffineMap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="AffineMap_8h_source.html">AffineMap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a491f21c36efbd2ad2e664d16948c016c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> = <a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">detail::AffineMapStorage</a></td></tr>
<tr class="separator:a491f21c36efbd2ad2e664d16948c016c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c493cf00ceed65b2a02cf54ae8d81cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a2c493cf00ceed65b2a02cf54ae8d81cd">AffineMap</a> ()</td></tr>
<tr class="separator:a2c493cf00ceed65b2a02cf54ae8d81cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd0836d686d1e4e23f9da8ff0cd54e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a6cd0836d686d1e4e23f9da8ff0cd54e0">AffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> *map)</td></tr>
<tr class="separator:a6cd0836d686d1e4e23f9da8ff0cd54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e928a43754d0403241cc043857352b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a7e928a43754d0403241cc043857352b0">AffineMap</a> (const <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;other)</td></tr>
<tr class="separator:a7e928a43754d0403241cc043857352b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba1e7b02aa6f6214cd573622a3a37af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a3ba1e7b02aa6f6214cd573622a3a37af">operator=</a> (const <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;other)=default</td></tr>
<tr class="separator:a3ba1e7b02aa6f6214cd573622a3a37af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce6ee55edc21c008a3bf8d10a2d726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a07ce6ee55edc21c008a3bf8d10a2d726">getContext</a> () const</td></tr>
<tr class="separator:a07ce6ee55edc21c008a3bf8d10a2d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48ad5d56bcd980115ffc4ba5f052295"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aa48ad5d56bcd980115ffc4ba5f052295">operator bool</a> ()</td></tr>
<tr class="separator:aa48ad5d56bcd980115ffc4ba5f052295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7381857cac60752009640964e99172c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a7381857cac60752009640964e99172c2">operator==</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other) const</td></tr>
<tr class="separator:a7381857cac60752009640964e99172c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad066a62bd10ed01423748bdd913565be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ad066a62bd10ed01423748bdd913565be">operator!=</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other) const</td></tr>
<tr class="separator:ad066a62bd10ed01423748bdd913565be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33ea095c58804447510ad5ff023975c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#af33ea095c58804447510ad5ff023975c">isIdentity</a> () const</td></tr>
<tr class="separator:af33ea095c58804447510ad5ff023975c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5752e3927fef1c67c276e3aa956e9cfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a5752e3927fef1c67c276e3aa956e9cfe">isEmpty</a> () const</td></tr>
<tr class="memdesc:a5752e3927fef1c67c276e3aa956e9cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is an empty map, i.e., () -&gt; ().  <a href="#a5752e3927fef1c67c276e3aa956e9cfe">More...</a><br /></td></tr>
<tr class="separator:a5752e3927fef1c67c276e3aa956e9cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4197b91018d6d6badaccdcb0ce6c1e12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a4197b91018d6d6badaccdcb0ce6c1e12">isSingleConstant</a> () const</td></tr>
<tr class="memdesc:a4197b91018d6d6badaccdcb0ce6c1e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is a single result constant function.  <a href="#a4197b91018d6d6badaccdcb0ce6c1e12">More...</a><br /></td></tr>
<tr class="separator:a4197b91018d6d6badaccdcb0ce6c1e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029344fc35377bfa5b59b51edaf304d9"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a029344fc35377bfa5b59b51edaf304d9">getSingleConstantResult</a> () const</td></tr>
<tr class="separator:a029344fc35377bfa5b59b51edaf304d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ecd6ef18c3c3fa94c053f5fba67bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ae0ecd6ef18c3c3fa94c053f5fba67bdf">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:ae0ecd6ef18c3c3fa94c053f5fba67bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac981930c6d7e6b46b46c4c678d9b5f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ac981930c6d7e6b46b46c4c678d9b5f17">dump</a> () const</td></tr>
<tr class="separator:ac981930c6d7e6b46b46c4c678d9b5f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bef7af11cc1451c2e440718c5a5933"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a75bef7af11cc1451c2e440718c5a5933">getNumDims</a> () const</td></tr>
<tr class="separator:a75bef7af11cc1451c2e440718c5a5933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750b299a4842c7965de35bd2cb1479a0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a750b299a4842c7965de35bd2cb1479a0">getNumSymbols</a> () const</td></tr>
<tr class="separator:a750b299a4842c7965de35bd2cb1479a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f194ae3b4baf33c67b10c9f795b564"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a96f194ae3b4baf33c67b10c9f795b564">getNumResults</a> () const</td></tr>
<tr class="separator:a96f194ae3b4baf33c67b10c9f795b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa821f07143bcad97d6df532c232129a3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#aa821f07143bcad97d6df532c232129a3">getNumInputs</a> () const</td></tr>
<tr class="separator:aa821f07143bcad97d6df532c232129a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79007ce78cfccb064390c22a4af6037c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a79007ce78cfccb064390c22a4af6037c">getResults</a> () const</td></tr>
<tr class="separator:a79007ce78cfccb064390c22a4af6037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60458b2cba87d765341cd6b2d41ed12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ac60458b2cba87d765341cd6b2d41ed12">getResult</a> (unsigned idx) const</td></tr>
<tr class="separator:ac60458b2cba87d765341cd6b2d41ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113361b495944795b99c988b9f658702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a113361b495944795b99c988b9f658702">walkExprs</a> (std::function&lt; void(<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>)&gt; callback) const</td></tr>
<tr class="separator:a113361b495944795b99c988b9f658702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fab765031b4744d145fa000ddaf7b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a4fab765031b4744d145fa000ddaf7b7e">replaceDimsAndSymbols</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; dimReplacements, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; symReplacements, unsigned numResultDims, unsigned numResultSyms)</td></tr>
<tr class="separator:a4fab765031b4744d145fa000ddaf7b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ca0db439fef10258b8936b78a26f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a91ca0db439fef10258b8936b78a26f80">constantFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operandConstants, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;results) const</td></tr>
<tr class="separator:a91ca0db439fef10258b8936b78a26f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199fd51c350d4006ca1d25914191177b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a199fd51c350d4006ca1d25914191177b">compose</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="separator:a199fd51c350d4006ca1d25914191177b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf84ff79379721e0ee0dda55a0f54f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a9cf84ff79379721e0ee0dda55a0f54f3">isProjectedPermutation</a> ()</td></tr>
<tr class="separator:a9cf84ff79379721e0ee0dda55a0f54f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd7d565952ab5269bed8be9ceb359e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#adcd7d565952ab5269bed8be9ceb359e4">isPermutation</a> ()</td></tr>
<tr class="memdesc:adcd7d565952ab5269bed8be9ceb359e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> represents a symbol-less permutation map.  <a href="#adcd7d565952ab5269bed8be9ceb359e4">More...</a><br /></td></tr>
<tr class="separator:adcd7d565952ab5269bed8be9ceb359e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67f5285a34604f1adeb20208b3637fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#af67f5285a34604f1adeb20208b3637fd">getSubMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; resultPos)</td></tr>
<tr class="memdesc:af67f5285a34604f1adeb20208b3637fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of the <code>resultPos</code> subset.  <a href="#af67f5285a34604f1adeb20208b3637fd">More...</a><br /></td></tr>
<tr class="separator:af67f5285a34604f1adeb20208b3637fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a3cfca2eb29fddf3c4bda714cccaa53f9">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero result affine map with no dimensions or symbols: () -&gt; ().  <a href="#a3cfca2eb29fddf3c4bda714cccaa53f9">More...</a><br /></td></tr>
<tr class="separator:a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f302ff8d54155617c27b787d0d149e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a75f302ff8d54155617c27b787d0d149e">get</a> (unsigned dimCount, unsigned symbolCount, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; results)</td></tr>
<tr class="separator:a75f302ff8d54155617c27b787d0d149e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98c7861efe6542d1e99c8172cc6061a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#ad98c7861efe6542d1e99c8172cc6061a">getConstantMap</a> (int64_t val, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad98c7861efe6542d1e99c8172cc6061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single constant result affine map.  <a href="#ad98c7861efe6542d1e99c8172cc6061a">More...</a><br /></td></tr>
<tr class="separator:ad98c7861efe6542d1e99c8172cc6061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ed2c2a4c743450a4a999fa6db1bf84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a39ed2c2a4c743450a4a999fa6db1bf84">getMultiDimIdentityMap</a> (unsigned numDims, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a39ed2c2a4c743450a4a999fa6db1bf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> with 'numDims' identity result dim exprs.  <a href="#a39ed2c2a4c743450a4a999fa6db1bf84">More...</a><br /></td></tr>
<tr class="separator:a39ed2c2a4c743450a4a999fa6db1bf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd08312b1039c20f008d2f6785c47816"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#acd08312b1039c20f008d2f6785c47816">getPermutationMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; permutation, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:acd08312b1039c20f008d2f6785c47816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> representing a permutation.  <a href="#acd08312b1039c20f008d2f6785c47816">More...</a><br /></td></tr>
<tr class="separator:acd08312b1039c20f008d2f6785c47816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a07dc7e1df4f0d9e9c4d1038f7a688527"><td class="memItemLeft" align="right" valign="top">::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html#a07dc7e1df4f0d9e9c4d1038f7a688527">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="separator:a07dc7e1df4f0d9e9c4d1038f7a688527"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html">Type</a>'s, and they are uniqued. Eg: (d0, d1) -&gt; (d0/128, d0 mod 128, d1) The names used (d0, d1) don't matter - it's the mathematical function that is unique to this affine map. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a491f21c36efbd2ad2e664d16948c016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491f21c36efbd2ad2e664d16948c016c">&#9670;&nbsp;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">mlir::AffineMap::ImplType</a> =  <a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">detail::AffineMapStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2c493cf00ceed65b2a02cf54ae8d81cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c493cf00ceed65b2a02cf54ae8d81cd">&#9670;&nbsp;</a></span>AffineMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::AffineMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cd0836d686d1e4e23f9da8ff0cd54e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd0836d686d1e4e23f9da8ff0cd54e0">&#9670;&nbsp;</a></span>AffineMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::AffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e928a43754d0403241cc043857352b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e928a43754d0403241cc043857352b0">&#9670;&nbsp;</a></span>AffineMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::AffineMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a199fd51c350d4006ca1d25914191177b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199fd51c350d4006ca1d25914191177b">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::compose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> resulting from composing <code>this</code> with <code>map</code>. The resulting <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> has as many <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> as <code>map</code> and as many <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression. ">AffineSymbolExpr</a> as the concatenation of <code>this</code> and <code>map</code> (in which case the symbols of <code>this</code> map come first).</p>
<p>Prerequisites: The maps are composable, i.e. that the number of <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> of <code>this</code> matches the number of results of <code>map</code>.</p>
<p>Example: map1: <code>(d0, d1)[s0, s1] -&gt; (d0 + 1 + s1, d1 - 1 - s0)</code> map2: <code>(d0)[s0] -&gt; (d0 + s0, d0 - s0)</code> map1.compose(map2): <code>(d0)[s0, s1, s2] -&gt; (d0 + s1 + s2 + 1, d0 - s0 - s2 - 1)</code> </p>

</div>
</div>
<a id="a91ca0db439fef10258b8936b78a26f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ca0db439fef10258b8936b78a26f80">&#9670;&nbsp;</a></span>constantFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> AffineMap::constantFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operandConstants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Folds the results of the application of an affine map on the provided operands to a constant if possible.</p>
<p>Folds the results of the application of an affine map on the provided operands to a constant if possible. Returns false if the folding happens, true otherwise. </p>

</div>
</div>
<a id="ac981930c6d7e6b46b46c4c678d9b5f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac981930c6d7e6b46b46c4c678d9b5f17">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineMap::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cfca2eb29fddf3c4bda714cccaa53f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfca2eb29fddf3c4bda714cccaa53f9">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero result affine map with no dimensions or symbols: () -&gt; (). </p>

</div>
</div>
<a id="a75f302ff8d54155617c27b787d0d149e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f302ff8d54155617c27b787d0d149e">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dimCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>symbolCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad98c7861efe6542d1e99c8172cc6061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98c7861efe6542d1e99c8172cc6061a">&#9670;&nbsp;</a></span>getConstantMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getConstantMap </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a single constant result affine map. </p>

</div>
</div>
<a id="a07ce6ee55edc21c008a3bf8d10a2d726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce6ee55edc21c008a3bf8d10a2d726">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * AffineMap::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39ed2c2a4c743450a4a999fa6db1bf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ed2c2a4c743450a4a999fa6db1bf84">&#9670;&nbsp;</a></span>getMultiDimIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMultiDimIdentityMap </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> with 'numDims' identity result dim exprs. </p>

</div>
</div>
<a id="a75bef7af11cc1451c2e440718c5a5933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bef7af11cc1451c2e440718c5a5933">&#9670;&nbsp;</a></span>getNumDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AffineMap::getNumDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa821f07143bcad97d6df532c232129a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa821f07143bcad97d6df532c232129a3">&#9670;&nbsp;</a></span>getNumInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AffineMap::getNumInputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96f194ae3b4baf33c67b10c9f795b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f194ae3b4baf33c67b10c9f795b564">&#9670;&nbsp;</a></span>getNumResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AffineMap::getNumResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a750b299a4842c7965de35bd2cb1479a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750b299a4842c7965de35bd2cb1479a0">&#9670;&nbsp;</a></span>getNumSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned AffineMap::getNumSymbols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd08312b1039c20f008d2f6785c47816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd08312b1039c20f008d2f6785c47816">&#9670;&nbsp;</a></span>getPermutationMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> representing a permutation. </p>
<p>Returns an <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> representing a permutation. The permutation is expressed as a non-empty vector of integers. E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> will be expressed with <code>permutation = [1,2,0]</code>. All values in <code>permutation</code> must be integers, in the range 0..<code>permutation.size()-1</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

</div>
</div>
<a id="ac60458b2cba87d765341cd6b2d41ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60458b2cba87d765341cd6b2d41ed12">&#9670;&nbsp;</a></span>getResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> AffineMap::getResult </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79007ce78cfccb064390c22a4af6037c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79007ce78cfccb064390c22a4af6037c">&#9670;&nbsp;</a></span>getResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; AffineMap::getResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a029344fc35377bfa5b59b51edaf304d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029344fc35377bfa5b59b51edaf304d9">&#9670;&nbsp;</a></span>getSingleConstantResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t AffineMap::getSingleConstantResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the constant result of this map. This methods asserts that the map has a single constant result. </p>

</div>
</div>
<a id="af67f5285a34604f1adeb20208b3637fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67f5285a34604f1adeb20208b3637fd">&#9670;&nbsp;</a></span>getSubMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getSubMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>resultPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of the <code>resultPos</code> subset. </p>

</div>
</div>
<a id="a5752e3927fef1c67c276e3aa956e9cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5752e3927fef1c67c276e3aa956e9cfe">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is an empty map, i.e., () -&gt; (). </p>

</div>
</div>
<a id="af33ea095c58804447510ad5ff023975c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33ea095c58804447510ad5ff023975c">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this affine map is an identity affine map. An identity affine map corresponds to an identity affine function on the dimensional identifiers. </p>

</div>
</div>
<a id="adcd7d565952ab5269bed8be9ceb359e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd7d565952ab5269bed8be9ceb359e4">&#9670;&nbsp;</a></span>isPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> represents a symbol-less permutation map. </p>

</div>
</div>
<a id="a9cf84ff79379721e0ee0dda55a0f54f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf84ff79379721e0ee0dda55a0f54f3">&#9670;&nbsp;</a></span>isProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isProjectedPermutation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> represents a subset (i.e. a projection) of a symbol-less permutation map. </p>

</div>
</div>
<a id="a4197b91018d6d6badaccdcb0ce6c1e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4197b91018d6d6badaccdcb0ce6c1e12">&#9670;&nbsp;</a></span>isSingleConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AffineMap::isSingleConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is a single result constant function. </p>

</div>
</div>
<a id="aa48ad5d56bcd980115ffc4ba5f052295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48ad5d56bcd980115ffc4ba5f052295">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad066a62bd10ed01423748bdd913565be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad066a62bd10ed01423748bdd913565be">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineMap::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ba1e7b02aa6f6214cd573622a3a37af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba1e7b02aa6f6214cd573622a3a37af">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&amp; mlir::AffineMap::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7381857cac60752009640964e99172c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7381857cac60752009640964e99172c2">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineMap::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0ecd6ef18c3c3fa94c053f5fba67bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ecd6ef18c3c3fa94c053f5fba67bdf">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineMap::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fab765031b4744d145fa000ddaf7b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fab765031b4744d145fa000ddaf7b7e">&#9670;&nbsp;</a></span>replaceDimsAndSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replaceDimsAndSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>dimReplacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>symReplacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numResultDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numResultSyms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method substitutes any uses of dimensions and symbols (e.g. dim#0 with dimReplacements[0]) in subexpressions and returns the modified expression mapping. Because this can be used to eliminate dims and symbols, the client needs to specify the number of dims and symbols in the result. The returned map always has the same number of results. </p>

</div>
</div>
<a id="a113361b495944795b99c988b9f658702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113361b495944795b99c988b9f658702">&#9670;&nbsp;</a></span>walkExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineMap::walkExprs </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk all of the <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>'s in this mapping. Each node in an expression tree is visited in postorder. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a07dc7e1df4f0d9e9c4d1038f7a688527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07dc7e1df4f0d9e9c4d1038f7a688527">&#9670;&nbsp;</a></span>hash_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::llvm::hash_code hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="AffineMap_8h_source.html">AffineMap.h</a></li>
<li>lib/IR/<a class="el" href="AffineMap_8cpp.html">AffineMap.cpp</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="MLIRContext_8cpp.html">MLIRContext.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
