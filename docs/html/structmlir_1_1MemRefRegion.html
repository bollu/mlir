<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: mlir::MemRefRegion Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1MemRefRegion-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::MemRefRegion Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for mlir::MemRefRegion:</div>
<div class="dyncontent">
<div class="center"><img src="structmlir_1_1MemRefRegion__coll__graph.png" border="0" usemap="#mlir_1_1MemRefRegion_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1MemRefRegion_coll__map" id="mlir_1_1MemRefRegion_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1Value.html" title="mlir::Value" alt="" coords="5,351,89,377"/>
<area shape="rect" id="node3" href="classmlir_1_1Location.html" title="mlir::Location" alt="" coords="113,351,213,377"/>
<area shape="rect" id="node4" href="classmlir_1_1LocationAttr.html" title="mlir::LocationAttr" alt="" coords="103,261,224,288"/>
<area shape="rect" id="node5" href="classmlir_1_1Attribute.html" title="mlir::Attribute" alt="" coords="113,185,213,212"/>
<area shape="rect" id="node6" href="classmlir_1_1AttributeStorage.html" title="mlir::AttributeStorage" alt="" coords="91,96,236,123"/>
<area shape="rect" id="node7" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html" title="mlir::StorageUniquer\l::BaseStorage" alt="" coords="93,5,234,47"/>
<area shape="rect" id="node8" href="classmlir_1_1FlatAffineConstraints.html" title="mlir::FlatAffineConstraints" alt="" coords="237,351,412,377"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94163255db4acde7702f9b8de48b7982"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a94163255db4acde7702f9b8de48b7982">MemRefRegion</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="structmlir_1_1MemRefRegion.html#a41c25453cbeaa5d9345d97af75e08fd7">loc</a>)</td></tr>
<tr class="separator:a94163255db4acde7702f9b8de48b7982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add33daeb279e80255487b6ec186db58b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#add33daeb279e80255487b6ec186db58b">compute</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned loopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState=nullptr, bool addMemRefDimBounds=true)</td></tr>
<tr class="separator:add33daeb279e80255487b6ec186db58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aeb7fda8e9279474e2596bdff711433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a8aeb7fda8e9279474e2596bdff711433">getConstraints</a> ()</td></tr>
<tr class="separator:a8aeb7fda8e9279474e2596bdff711433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2c073abc47a8a4c461318484f2e9ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#abb2c073abc47a8a4c461318484f2e9ea">getConstraints</a> () const</td></tr>
<tr class="separator:abb2c073abc47a8a4c461318484f2e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f77f916448c7949d85cf873a1950375"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a8f77f916448c7949d85cf873a1950375">isWrite</a> () const</td></tr>
<tr class="separator:a8f77f916448c7949d85cf873a1950375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d177f4d61387d7925c2873d72c8da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a154d177f4d61387d7925c2873d72c8da">setWrite</a> (bool flag)</td></tr>
<tr class="separator:a154d177f4d61387d7925c2873d72c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a7d17a661ec58a29ce543121f4bc9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a22a7d17a661ec58a29ce543121f4bc9d">getConstantBoundingSizeAndShape</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *shape=nullptr, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&gt; *lbs=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lbDivisors=nullptr) const</td></tr>
<tr class="separator:a22a7d17a661ec58a29ce543121f4bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f83f0a4b7c3393b18dd32a3c83b5db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a9f83f0a4b7c3393b18dd32a3c83b5db6">getConstantBoundOnDimSize</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *lbFloorDivisor=nullptr) const</td></tr>
<tr class="separator:a9f83f0a4b7c3393b18dd32a3c83b5db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaecac872899184676e1fde7b2460e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#abaecac872899184676e1fde7b2460e1c">getRegionSize</a> ()</td></tr>
<tr class="memdesc:abaecac872899184676e1fde7b2460e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> in bytes.  <a href="#abaecac872899184676e1fde7b2460e1c">More...</a><br /></td></tr>
<tr class="separator:abaecac872899184676e1fde7b2460e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2761578967822bb7853e072a1a29bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">unionBoundingBox</a> (const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;other)</td></tr>
<tr class="separator:aa2761578967822bb7853e072a1a29bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22317444c57ececdfd0b3f5497d1971c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">getRank</a> () const</td></tr>
<tr class="memdesc:a22317444c57ececdfd0b3f5497d1971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the memref that this region corresponds to.  <a href="#a22317444c57ececdfd0b3f5497d1971c">More...</a><br /></td></tr>
<tr class="separator:a22317444c57ececdfd0b3f5497d1971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af4996f781f24e9f3c57256a95ae58b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#af4996f781f24e9f3c57256a95ae58b8c">memref</a></td></tr>
<tr class="memdesc:af4996f781f24e9f3c57256a95ae58b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memref that this region corresponds to.  <a href="#af4996f781f24e9f3c57256a95ae58b8c">More...</a><br /></td></tr>
<tr class="separator:af4996f781f24e9f3c57256a95ae58b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e52e7911cae506b5b206f9dc6b3642"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#ae9e52e7911cae506b5b206f9dc6b3642">write</a></td></tr>
<tr class="memdesc:ae9e52e7911cae506b5b206f9dc6b3642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read or write.  <a href="#ae9e52e7911cae506b5b206f9dc6b3642">More...</a><br /></td></tr>
<tr class="separator:ae9e52e7911cae506b5b206f9dc6b3642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c25453cbeaa5d9345d97af75e08fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a41c25453cbeaa5d9345d97af75e08fd7">loc</a></td></tr>
<tr class="separator:a41c25453cbeaa5d9345d97af75e08fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b96081a1d38fd5d731dfacca3deb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#af78b96081a1d38fd5d731dfacca3deb8">cst</a></td></tr>
<tr class="separator:af78b96081a1d38fd5d731dfacca3deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94163255db4acde7702f9b8de48b7982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94163255db4acde7702f9b8de48b7982">&#9670;&nbsp;</a></span>MemRefRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::MemRefRegion::MemRefRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add33daeb279e80255487b6ec186db58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add33daeb279e80255487b6ec186db58b">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> MemRefRegion::compute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addMemRefDimBounds</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst. The computed region's 'cst' field has exactly as many dimensional identifiers as the rank of the memref, and <em>potentially</em> additional symbolic identifiers which could include any of the loop IVs surrounding opInst up until 'loopDepth' and another additional Function symbols involved with the access (for eg., those appear in affine.apply's, loop bounds, etc.). If 'sliceState' is non-null, operands from 'sliceState' are added as symbols, and the following constraints are added to the system: *) Inequality constraints which represent loop bounds for 'sliceState' operands which are loop IVS (these represent the destination loop IVs of the slice, and are added as symbols to <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a>'s constraint system). *) Inequality constraints for the slice bounds in 'sliceState', which represent the bounds on the loop IVs in this constraint system w.r.t to slice operands (which correspond to symbols). If 'addMemRefDimBounds' is true, constant upper/lower bounds [0, memref.getDimSize(i)) are added for each MemRef dimension 'i'.</p>
<p>For example, the memref region for this operation at loopDepth = 1 will be:</p>
<p>affine.for i = 0 to 32 { affine.for ii = i to (d0) -&gt; (d0 + 8) (i) { load A[ii] } }</p>
<p>{memref = A, write = false, {i &lt;= m0 &lt;= i + 7} } The last field is a 2-d <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> symbolic in i.</p>
<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst and any additional Function symbols. </p>

</div>
</div>
<a id="a22a7d17a661ec58a29ce543121f4bc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a7d17a661ec58a29ce543121f4bc9d">&#9670;&nbsp;</a></span>getConstantBoundingSizeAndShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; MemRefRegion::getConstantBoundingSizeAndShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>shape</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>lbs</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lbDivisors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a constant upper bound on the number of elements in this region if bounded by a known constant (always possible for static shapes), None otherwise. Note that the symbols of the region are treated specially, i.e., the returned bounding constant holds for <em>any given</em> value of the symbol identifiers. The 'shape' vector is set to the corresponding dimension-wise bounds major to minor. We use int64_t instead of uint64_t since index types can be at most int64_t. </p>

</div>
</div>
<a id="a9f83f0a4b7c3393b18dd32a3c83b5db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f83f0a4b7c3393b18dd32a3c83b5db6">&#9670;&nbsp;</a></span>getConstantBoundOnDimSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;int64_t&gt; mlir::MemRefRegion::getConstantBoundOnDimSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>lbFloorDivisor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A wrapper around <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a159b9a3d63c5f64c2230e5e661c52217">FlatAffineConstraints::getConstantBoundOnDimSize()</a>. 'pos' corresponds to the position of the memref shape's dimension (major to minor) which matches 1:1 with the dimensional identifier positions in </p>

</div>
</div>
<a id="a8aeb7fda8e9279474e2596bdff711433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aeb7fda8e9279474e2596bdff711433">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>* mlir::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb2c073abc47a8a4c461318484f2e9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2c073abc47a8a4c461318484f2e9ea">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>* mlir::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22317444c57ececdfd0b3f5497d1971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22317444c57ececdfd0b3f5497d1971c">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MemRefRegion::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rank of the memref that this region corresponds to. </p>

</div>
</div>
<a id="abaecac872899184676e1fde7b2460e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaecac872899184676e1fde7b2460e1c">&#9670;&nbsp;</a></span>getRegionSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; MemRefRegion::getRegionSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of this <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> in bytes. </p>

</div>
</div>
<a id="a8f77f916448c7949d85cf873a1950375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f77f916448c7949d85cf873a1950375">&#9670;&nbsp;</a></span>isWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::MemRefRegion::isWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a154d177f4d61387d7925c2873d72c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154d177f4d61387d7925c2873d72c8da">&#9670;&nbsp;</a></span>setWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::MemRefRegion::setWrite </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2761578967822bb7853e072a1a29bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2761578967822bb7853e072a1a29bac">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> MemRefRegion::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af78b96081a1d38fd5d731dfacca3deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78b96081a1d38fd5d731dfacca3deb8">&#9670;&nbsp;</a></span>cst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> mlir::MemRefRegion::cst</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classmlir_1_1Region.html">Region</a> (data space) of the memref accessed. This set will thus have at least as many dimensional identifiers as the shape dimensionality of the memref, and these are the leading dimensions of the set appearing in that order (major to minor / outermost to innermost). There may be additional identifiers since getMemRefRegion() is called with a specific loop depth, and thus the region is symbolic in the outer surrounding loops at that depth. </p>

</div>
</div>
<a id="a41c25453cbeaa5d9345d97af75e08fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c25453cbeaa5d9345d97af75e08fd7">&#9670;&nbsp;</a></span>loc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Location.html">Location</a> mlir::MemRefRegion::loc</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If there is more than one load/store op associated with the region, the location information would correspond to one of those op's. </p>

</div>
</div>
<a id="af4996f781f24e9f3c57256a95ae58b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4996f781f24e9f3c57256a95ae58b8c">&#9670;&nbsp;</a></span>memref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::MemRefRegion::memref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memref that this region corresponds to. </p>

</div>
</div>
<a id="ae9e52e7911cae506b5b206f9dc6b3642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e52e7911cae506b5b206f9dc6b3642">&#9670;&nbsp;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::MemRefRegion::write</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read or write. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Analysis/<a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a></li>
<li>lib/Analysis/<a class="el" href="Analysis_2Utils_8cpp.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
