<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: mlir::FlatAffineConstraints Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1FlatAffineConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::FlatAffineConstraints Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab47fbec6c4aff6faece95521b103fed2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> { <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2a2ee94b4e0a594b0b54351659320e6ba7">Dimension</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2ae3c7272b03244406768692d4fea34372">Symbol</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2a5cbad5ec78394bb35d4d33f15993f778">Local</a>
 }</td></tr>
<tr class="separator:ab47fbec6c4aff6faece95521b103fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a67d39a02671f878053effe3493e6544a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a67d39a02671f878053effe3493e6544a">FlatAffineConstraints</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; idArgs={})</td></tr>
<tr class="separator:a67d39a02671f878053effe3493e6544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6c8b02abc69721d025b1ca23db2b2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2c6c8b02abc69721d025b1ca23db2b2e">FlatAffineConstraints</a> (unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; idArgs={})</td></tr>
<tr class="separator:a2c6c8b02abc69721d025b1ca23db2b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485ccacf0a047233d064351ff31cd9c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a485ccacf0a047233d064351ff31cd9c1">FlatAffineConstraints</a> (const HyperRectangularSet &amp;set)</td></tr>
<tr class="separator:a485ccacf0a047233d064351ff31cd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed4103886f4e5761c76b4073aa1de73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9ed4103886f4e5761c76b4073aa1de73">FlatAffineConstraints</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;avm)</td></tr>
<tr class="separator:a9ed4103886f4e5761c76b4073aa1de73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4333c62fce350f020f58b6fb0d2faf0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4333c62fce350f020f58b6fb0d2faf0f">FlatAffineConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef)</td></tr>
<tr class="separator:a4333c62fce350f020f58b6fb0d2faf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a04009cfc4f3c97dbff1cf9594c0f7c9a">FlatAffineConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>.  <a href="#a04009cfc4f3c97dbff1cf9594c0f7c9a">More...</a><br /></td></tr>
<tr class="separator:a04009cfc4f3c97dbff1cf9594c0f7c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947eee63586b73c35a239e63248a9bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a7947eee63586b73c35a239e63248a9bc">FlatAffineConstraints</a> (const <a class="el" href="classmlir_1_1IntegerValueSet.html">IntegerValueSet</a> &amp;set)</td></tr>
<tr class="memdesc:a7947eee63586b73c35a239e63248a9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an affine constraint system from an <a class="el" href="classmlir_1_1IntegerValueSet.html" title="An IntegerValueSet is an integer set plus its operands. ">IntegerValueSet</a>.  <a href="#a7947eee63586b73c35a239e63248a9bc">More...</a><br /></td></tr>
<tr class="separator:a7947eee63586b73c35a239e63248a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5f989f74501c929910cc94637209ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4b5f989f74501c929910cc94637209ce">FlatAffineConstraints</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="separator:a4b5f989f74501c929910cc94637209ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84814b8b20bb9768814270d71952a9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af84814b8b20bb9768814270d71952a9d">FlatAffineConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef, <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="separator:af84814b8b20bb9768814270d71952a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074122b77beb705d010169667ae9efe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8074122b77beb705d010169667ae9efe">FlatAffineConstraints</a> (const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;map)</td></tr>
<tr class="separator:a8074122b77beb705d010169667ae9efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8824fdedbdc984ff79e3b812016f3b2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8824fdedbdc984ff79e3b812016f3b2c">~FlatAffineConstraints</a> ()</td></tr>
<tr class="separator:a8824fdedbdc984ff79e3b812016f3b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5165263cbbc9080ca858b235f98cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afb5165263cbbc9080ca858b235f98cd7">reset</a> (unsigned numReservedInequalities, unsigned numReservedEqualities, unsigned numReservedCols, unsigned numDims, unsigned numSymbols, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; idArgs={})</td></tr>
<tr class="separator:afb5165263cbbc9080ca858b235f98cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cc51d0f0dc264158dd9fd0bb47cd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae0cc51d0f0dc264158dd9fd0bb47cd28">reset</a> (unsigned numDims=0, unsigned numSymbols=0, unsigned numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; idArgs={})</td></tr>
<tr class="separator:ae0cc51d0f0dc264158dd9fd0bb47cd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4973d2d62dbf7779d1e350fec9911e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6e4973d2d62dbf7779d1e350fec9911e">append</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="separator:a6e4973d2d62dbf7779d1e350fec9911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc2ce92fc0297fbc8bfc62241c4472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6ddc2ce92fc0297fbc8bfc62241c4472">isEmpty</a> () const</td></tr>
<tr class="separator:a6ddc2ce92fc0297fbc8bfc62241c4472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318337e58529a47cd9c9e38e11b3e67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af318337e58529a47cd9c9e38e11b3e67">isEmptyByGCDTest</a> () const</td></tr>
<tr class="separator:af318337e58529a47cd9c9e38e11b3e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0932fcc3e8ee32f1af944a1f33a9abc3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0932fcc3e8ee32f1af944a1f33a9abc3">clone</a> () const</td></tr>
<tr class="separator:a0932fcc3e8ee32f1af944a1f33a9abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aaeb4c8e8b0bf86fa1609a32bd9028536">atEq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified equality row and column.  <a href="#aaeb4c8e8b0bf86fa1609a32bd9028536">More...</a><br /></td></tr>
<tr class="separator:aaeb4c8e8b0bf86fa1609a32bd9028536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b80ebb1a0929a30c4401d297a420d9e"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0b80ebb1a0929a30c4401d297a420d9e">atEq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a0b80ebb1a0929a30c4401d297a420d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950735c15d0d1757984210922c7118c0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a950735c15d0d1757984210922c7118c0">atIneq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="separator:a950735c15d0d1757984210922c7118c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ba9253168af09117779ede6e1020f"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae02ba9253168af09117779ede6e1020f">atIneq</a> (unsigned i, unsigned <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:ae02ba9253168af09117779ede6e1020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dafa2401aead0909b87b92d41bfbbd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad6dafa2401aead0909b87b92d41bfbbd">getNumCols</a> () const</td></tr>
<tr class="memdesc:ad6dafa2401aead0909b87b92d41bfbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the constraint system.  <a href="#ad6dafa2401aead0909b87b92d41bfbbd">More...</a><br /></td></tr>
<tr class="separator:ad6dafa2401aead0909b87b92d41bfbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963e712e6a344acbadfa413940487704"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a963e712e6a344acbadfa413940487704">getNumEqualities</a> () const</td></tr>
<tr class="separator:a963e712e6a344acbadfa413940487704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f382f6a3f7062ff36e3dce1920c4c9"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a50f382f6a3f7062ff36e3dce1920c4c9">getNumInequalities</a> () const</td></tr>
<tr class="separator:a50f382f6a3f7062ff36e3dce1920c4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597e435e789ef833a1e0cc80cd82a388"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a597e435e789ef833a1e0cc80cd82a388">getNumReservedEqualities</a> () const</td></tr>
<tr class="separator:a597e435e789ef833a1e0cc80cd82a388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3617c7a6eef7e4c3d1b1845025900adf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3617c7a6eef7e4c3d1b1845025900adf">getNumReservedInequalities</a> () const</td></tr>
<tr class="separator:a3617c7a6eef7e4c3d1b1845025900adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0673b512906bb0fed9e4c7244f9f0217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0673b512906bb0fed9e4c7244f9f0217">getEquality</a> (unsigned idx) const</td></tr>
<tr class="separator:a0673b512906bb0fed9e4c7244f9f0217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b9b04e17d80d48a79c0e09710c2be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a92b9b04e17d80d48a79c0e09710c2be6">getInequality</a> (unsigned idx) const</td></tr>
<tr class="separator:a92b9b04e17d80d48a79c0e09710c2be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3713af3279fc39f3630a5a6b89031653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3713af3279fc39f3630a5a6b89031653">toAffineExpr</a> (unsigned idx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:a3713af3279fc39f3630a5a6b89031653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4150bc63be2852d5efbbd31d1b938a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac4150bc63be2852d5efbbd31d1b938a8">addAffineForOpDomain</a> (AffineForOp forOp)</td></tr>
<tr class="separator:ac4150bc63be2852d5efbbd31d1b938a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944078deda4fba2b98635152d2759bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a944078deda4fba2b98635152d2759bfe">addLowerOrUpperBound</a> (unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, bool eq, bool lower=true)</td></tr>
<tr class="separator:a944078deda4fba2b98635152d2759bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fe40151ae13ca4d10c425937ff70f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27fe40151ae13ca4d10c425937ff70f2">getSliceBounds</a> (unsigned offset, unsigned num, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbMaps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *ubMaps)</td></tr>
<tr class="separator:a27fe40151ae13ca4d10c425937ff70f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d2543f40e0fc1c4701f20d4b891deb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad5d2543f40e0fc1c4701f20d4b891deb">addSliceBounds</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="separator:ad5d2543f40e0fc1c4701f20d4b891deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a440a9b51c09ea27d100fb62fb32a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9a440a9b51c09ea27d100fb62fb32a7f">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inEq)</td></tr>
<tr class="separator:a9a440a9b51c09ea27d100fb62fb32a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df72c07b67e459ece93a1076344210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a45df72c07b67e459ece93a1076344210">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq)</td></tr>
<tr class="separator:a45df72c07b67e459ece93a1076344210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7876c2038d87d8df799eb8e8010670da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a7876c2038d87d8df799eb8e8010670da">addConstantLowerBound</a> (unsigned pos, int64_t lb)</td></tr>
<tr class="memdesc:a7876c2038d87d8df799eb8e8010670da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant lower bound constraint for the specified identifier.  <a href="#a7876c2038d87d8df799eb8e8010670da">More...</a><br /></td></tr>
<tr class="separator:a7876c2038d87d8df799eb8e8010670da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79201460364553813e818c2f4c47b26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae79201460364553813e818c2f4c47b26">addConstantUpperBound</a> (unsigned pos, int64_t ub)</td></tr>
<tr class="memdesc:ae79201460364553813e818c2f4c47b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant upper bound constraint for the specified identifier.  <a href="#ae79201460364553813e818c2f4c47b26">More...</a><br /></td></tr>
<tr class="separator:ae79201460364553813e818c2f4c47b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81cc0ca235dba7982f6cecc66f2506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9d81cc0ca235dba7982f6cecc66f2506">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dividend, int64_t divisor)</td></tr>
<tr class="separator:a9d81cc0ca235dba7982f6cecc66f2506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a6c2a425f192f14a650791fb1154c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a05a6c2a425f192f14a650791fb1154c3">addConstantLowerBound</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t lb)</td></tr>
<tr class="memdesc:a05a6c2a425f192f14a650791fb1154c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant lower bound constraint for the specified expression.  <a href="#a05a6c2a425f192f14a650791fb1154c3">More...</a><br /></td></tr>
<tr class="separator:a05a6c2a425f192f14a650791fb1154c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6023d999d0f85e8c9bf105767991199a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6023d999d0f85e8c9bf105767991199a">addConstantUpperBound</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t ub)</td></tr>
<tr class="memdesc:a6023d999d0f85e8c9bf105767991199a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant upper bound constraint for the specified expression.  <a href="#a6023d999d0f85e8c9bf105767991199a">More...</a><br /></td></tr>
<tr class="separator:a6023d999d0f85e8c9bf105767991199a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e4c5fcf51e01bf82d9d82a26ff316a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a06e4c5fcf51e01bf82d9d82a26ff316a">setIdToConstant</a> (unsigned pos, int64_t val)</td></tr>
<tr class="memdesc:a06e4c5fcf51e01bf82d9d82a26ff316a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the identifier at the specified position to a constant.  <a href="#a06e4c5fcf51e01bf82d9d82a26ff316a">More...</a><br /></td></tr>
<tr class="separator:a06e4c5fcf51e01bf82d9d82a26ff316a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dee3803932dd1553f52b71f0372b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a04dee3803932dd1553f52b71f0372b12">setIdToConstant</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id, int64_t val)</td></tr>
<tr class="separator:a04dee3803932dd1553f52b71f0372b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ff9510294db04bfac4065117f27645"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae1ff9510294db04bfac4065117f27645">findId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id, unsigned *pos) const</td></tr>
<tr class="separator:ae1ff9510294db04bfac4065117f27645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c40a21ee894ea756e84b90a1420d54d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a5c40a21ee894ea756e84b90a1420d54d">containsId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id) const</td></tr>
<tr class="separator:a5c40a21ee894ea756e84b90a1420d54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9555bccd54ea166ce653e262797218da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9555bccd54ea166ce653e262797218da">addDimId</a> (unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> id=nullptr)</td></tr>
<tr class="separator:a9555bccd54ea166ce653e262797218da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66197a3e2cc40803abe7cb12685571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a7e66197a3e2cc40803abe7cb12685571">addSymbolId</a> (unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> id=nullptr)</td></tr>
<tr class="separator:a7e66197a3e2cc40803abe7cb12685571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477866201deff5c6a17201fc8669dc15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a477866201deff5c6a17201fc8669dc15">addLocalId</a> (unsigned pos)</td></tr>
<tr class="separator:a477866201deff5c6a17201fc8669dc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faafc96161faad6ec9faf0fb546e4ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a2faafc96161faad6ec9faf0fb546e4ed">addId</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> kind, unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> id=nullptr)</td></tr>
<tr class="separator:a2faafc96161faad6ec9faf0fb546e4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c99c8a9d566c1f7fc37671d531c19a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a66c99c8a9d566c1f7fc37671d531c19a">addInductionVarOrTerminalSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id)</td></tr>
<tr class="separator:a66c99c8a9d566c1f7fc37671d531c19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6350cf623d371e8a91a3a18a08097983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6350cf623d371e8a91a3a18a08097983">composeMap</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *vMap)</td></tr>
<tr class="separator:a6350cf623d371e8a91a3a18a08097983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f95bfc66876ee75db55381eafbb8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a15f95bfc66876ee75db55381eafbb8f2">composeMatchingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other)</td></tr>
<tr class="separator:a15f95bfc66876ee75db55381eafbb8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d1457dc3d54274c1519c6553be921d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a63d1457dc3d54274c1519c6553be921d">projectOut</a> (unsigned pos, unsigned num)</td></tr>
<tr class="separator:a63d1457dc3d54274c1519c6553be921d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3d0c1b0bad5d54e4b5f91910c52503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8c3d0c1b0bad5d54e4b5f91910c52503">projectOut</a> (unsigned pos)</td></tr>
<tr class="separator:a8c3d0c1b0bad5d54e4b5f91910c52503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f74eab80eb71234f457d296716dbec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a49f74eab80eb71234f457d296716dbec">projectOut</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> id)</td></tr>
<tr class="memdesc:a49f74eab80eb71234f457d296716dbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html">Value</a> .  <a href="#a49f74eab80eb71234f457d296716dbec">More...</a><br /></td></tr>
<tr class="separator:a49f74eab80eb71234f457d296716dbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74219ea7114c7c5ddec36845a7369f6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a74219ea7114c7c5ddec36845a7369f6f">removeId</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a> idKind, unsigned pos)</td></tr>
<tr class="separator:a74219ea7114c7c5ddec36845a7369f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e3fb602c03ba136b94b31a58bca727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aa7e3fb602c03ba136b94b31a58bca727">removeId</a> (unsigned pos)</td></tr>
<tr class="separator:aa7e3fb602c03ba136b94b31a58bca727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282561f245c5a8ba5b8467af590d80f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a282561f245c5a8ba5b8467af590d80f8">removeDim</a> (unsigned pos)</td></tr>
<tr class="separator:a282561f245c5a8ba5b8467af590d80f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d4894b1c67f1e06424e1453c585bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae3d4894b1c67f1e06424e1453c585bbf">removeEquality</a> (unsigned pos)</td></tr>
<tr class="separator:ae3d4894b1c67f1e06424e1453c585bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21e6041df1c8414405c512d50a0da54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab21e6041df1c8414405c512d50a0da54">removeInequality</a> (unsigned pos)</td></tr>
<tr class="separator:ab21e6041df1c8414405c512d50a0da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4924b4c54d6823f8e52933ca960c1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad4924b4c54d6823f8e52933ca960c1ff">setDimSymbolSeparation</a> (unsigned newSymbolCount)</td></tr>
<tr class="separator:ad4924b4c54d6823f8e52933ca960c1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d00b3e95728c04dfbc98c2907e3b815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3d00b3e95728c04dfbc98c2907e3b815">convertLoopIVSymbolsToDims</a> ()</td></tr>
<tr class="memdesc:a3d00b3e95728c04dfbc98c2907e3b815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all symbol identifiers which are loop IVs to dim identifiers.  <a href="#a3d00b3e95728c04dfbc98c2907e3b815">More...</a><br /></td></tr>
<tr class="separator:a3d00b3e95728c04dfbc98c2907e3b815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201799397e672780c6bce3674f969f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a201799397e672780c6bce3674f969f3b">setAndEliminate</a> (unsigned pos, int64_t constVal)</td></tr>
<tr class="memdesc:a201799397e672780c6bce3674f969f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified identifier to a constant and removes it.  <a href="#a201799397e672780c6bce3674f969f3b">More...</a><br /></td></tr>
<tr class="separator:a201799397e672780c6bce3674f969f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e1041e7db596d628253f1d8d7c8222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a00e1041e7db596d628253f1d8d7c8222">constantFoldId</a> (unsigned pos)</td></tr>
<tr class="separator:a00e1041e7db596d628253f1d8d7c8222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad67b4c81a969b09cf5c4bc723cda93d5">constantFoldIdRange</a> (unsigned pos, unsigned num)</td></tr>
<tr class="separator:ad67b4c81a969b09cf5c4bc723cda93d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8348eba3bd5c81db503336ae2ebfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afeb8348eba3bd5c81db503336ae2ebfc">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="separator:afeb8348eba3bd5c81db503336ae2ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86efbe8f7101ca9946ef7978194e0549"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a86efbe8f7101ca9946ef7978194e0549">areIdsAlignedWithOther</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="separator:a86efbe8f7101ca9946ef7978194e0549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6511f180daae3af295023e7b45336"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a60f6511f180daae3af295023e7b45336">mergeAndAlignIdsWithOther</a> (unsigned offset, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *other)</td></tr>
<tr class="separator:a60f6511f180daae3af295023e7b45336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747fa3994a809e5994fdc32035b54e4b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a747fa3994a809e5994fdc32035b54e4b">getNumConstraints</a> () const</td></tr>
<tr class="separator:a747fa3994a809e5994fdc32035b54e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0937c7d6a0a23146fbc6d5caf5e95a8b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0937c7d6a0a23146fbc6d5caf5e95a8b">getNumIds</a> () const</td></tr>
<tr class="separator:a0937c7d6a0a23146fbc6d5caf5e95a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb25117553419fb47427704e6c9bb84"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0bb25117553419fb47427704e6c9bb84">getNumDimIds</a> () const</td></tr>
<tr class="separator:a0bb25117553419fb47427704e6c9bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8074c726e597eb5a963a68451bb7fe"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aff8074c726e597eb5a963a68451bb7fe">getNumSymbolIds</a> () const</td></tr>
<tr class="separator:aff8074c726e597eb5a963a68451bb7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221a2c98d7a9019f0a93cb1b070152f3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a221a2c98d7a9019f0a93cb1b070152f3">getNumDimAndSymbolIds</a> () const</td></tr>
<tr class="separator:a221a2c98d7a9019f0a93cb1b070152f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12365660bdc368e87b6fc73f12e3e86"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab12365660bdc368e87b6fc73f12e3e86">getNumLocalIds</a> () const</td></tr>
<tr class="separator:ab12365660bdc368e87b6fc73f12e3e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc5592f55bba9543cb957274d145e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aacc5592f55bba9543cb957274d145e97">getIds</a> () const</td></tr>
<tr class="separator:aacc5592f55bba9543cb957274d145e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df54b69026d3981d00de5ce8e1a4cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6df54b69026d3981d00de5ce8e1a4cd4">getIds</a> ()</td></tr>
<tr class="separator:a6df54b69026d3981d00de5ce8e1a4cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36e5e1a5b66abc593cf169bce4b19e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aa36e5e1a5b66abc593cf169bce4b19e4">getId</a> (unsigned pos) const</td></tr>
<tr class="memdesc:aa36e5e1a5b66abc593cf169bce4b19e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optional <a class="el" href="classmlir_1_1Value.html">Value</a> corresponding to the pos^th identifier.  <a href="#aa36e5e1a5b66abc593cf169bce4b19e4">More...</a><br /></td></tr>
<tr class="separator:aa36e5e1a5b66abc593cf169bce4b19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142fba494ecf189c0decb4f0c5133eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a142fba494ecf189c0decb4f0c5133eb8">getId</a> (unsigned pos)</td></tr>
<tr class="separator:a142fba494ecf189c0decb4f0c5133eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6825cb13390479a204da6d3b1124ff92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6825cb13390479a204da6d3b1124ff92">getIdValue</a> (unsigned pos) const</td></tr>
<tr class="separator:a6825cb13390479a204da6d3b1124ff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181c4aa2ddc90806d2b2f86bb6a91f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a181c4aa2ddc90806d2b2f86bb6a91f1a">getIdValues</a> (unsigned start, unsigned end, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *values) const</td></tr>
<tr class="separator:a181c4aa2ddc90806d2b2f86bb6a91f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5669e6de739424cd4e46e8cbc4c9b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae5669e6de739424cd4e46e8cbc4c9b5f">getAllIdValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *values) const</td></tr>
<tr class="separator:ae5669e6de739424cd4e46e8cbc4c9b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ff33d7c48f5d8de4f26b95f2a94034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a77ff33d7c48f5d8de4f26b95f2a94034">setIdValue</a> (unsigned pos, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a77ff33d7c48f5d8de4f26b95f2a94034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classmlir_1_1Value.html">Value</a> associated with the pos^th identifier.  <a href="#a77ff33d7c48f5d8de4f26b95f2a94034">More...</a><br /></td></tr>
<tr class="separator:a77ff33d7c48f5d8de4f26b95f2a94034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bda84f68040789ebf27848f7bcaa169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8bda84f68040789ebf27848f7bcaa169">setIdValues</a> (unsigned start, unsigned end, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; values)</td></tr>
<tr class="memdesc:a8bda84f68040789ebf27848f7bcaa169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Values associated with identifiers in the range [start, end).  <a href="#a8bda84f68040789ebf27848f7bcaa169">More...</a><br /></td></tr>
<tr class="separator:a8bda84f68040789ebf27848f7bcaa169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac662ea0313d9bcac2e44925b6be670e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac662ea0313d9bcac2e44925b6be670e8">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:ac662ea0313d9bcac2e44925b6be670e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears this list of constraints and copies other into it.  <a href="#ac662ea0313d9bcac2e44925b6be670e8">More...</a><br /></td></tr>
<tr class="separator:ac662ea0313d9bcac2e44925b6be670e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159b9a3d63c5f64c2230e5e661c52217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a159b9a3d63c5f64c2230e5e661c52217">getConstantBoundOnDimSize</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *lbFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *ub=nullptr) const</td></tr>
<tr class="separator:a159b9a3d63c5f64c2230e5e661c52217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a299832c686eb594598d8a61957e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad4a299832c686eb594598d8a61957e81">getConstantLowerBound</a> (unsigned pos) const</td></tr>
<tr class="separator:ad4a299832c686eb594598d8a61957e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908b49c8a201df00af8b924064116c19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a908b49c8a201df00af8b924064116c19">getConstantUpperBound</a> (unsigned pos) const</td></tr>
<tr class="separator:a908b49c8a201df00af8b924064116c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cdbe1cff606a9b364e734ca09dc52"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aad0cdbe1cff606a9b364e734ca09dc52">getLowerAndUpperBound</a> (unsigned pos, unsigned offset, unsigned num, unsigned symStartPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="separator:aad0cdbe1cff606a9b364e734ca09dc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa635e50de116843fba9c4d6213ce14c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afa635e50de116843fba9c4d6213ce14c">isHyperRectangular</a> (unsigned pos, unsigned num) const</td></tr>
<tr class="separator:afa635e50de116843fba9c4d6213ce14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a710d4a8812b2e76eb3908a5767dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab3a710d4a8812b2e76eb3908a5767dac">removeTrivialRedundancy</a> ()</td></tr>
<tr class="separator:ab3a710d4a8812b2e76eb3908a5767dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a60b9abcf1ae4683b7ed214125d4d05c8">removeRedundantInequalities</a> ()</td></tr>
<tr class="separator:a60b9abcf1ae4683b7ed214125d4d05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4985a33143cd113df0f945c2bb6d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4b4985a33143cd113df0f945c2bb6d8b">clearConstraints</a> ()</td></tr>
<tr class="separator:a4b4985a33143cd113df0f945c2bb6d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f2f50452ba560992138f6df070045e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a32f2f50452ba560992138f6df070045e">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:a32f2f50452ba560992138f6df070045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9755c04bef03df1b8130b1a4e76ac605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9755c04bef03df1b8130b1a4e76ac605">dump</a> () const</td></tr>
<tr class="separator:a9755c04bef03df1b8130b1a4e76ac605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A flat list of affine equalities and inequalities in the form. Inequality: c_0*x_0 + c_1*x_1 + .... + c_{n-1}*x_{n-1} &gt;= 0 Equality: c_0*x_0 + c_1*x_1 + .... + c_{n-1}*x_{n-1} == 0</p>
<p><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> stores coefficients in a contiguous buffer (one buffer for equalities and one for inequalities). The size of each buffer is numReservedCols * number of inequalities (or equalities). The reserved size is numReservedCols * numReservedInequalities (or numReservedEqualities). A coefficient (r, c) lives at the location numReservedCols * r + c in the buffer. The extra space between <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad6dafa2401aead0909b87b92d41bfbbd" title="Returns the number of columns in the constraint system. ">getNumCols()</a> and numReservedCols exists to prevent frequent movement of data when adding columns, especially at the end.</p>
<p>The identifiers x_0, x_1, ... appear in the order: dimensional identifiers, symbolic identifiers, and local identifiers. The local identifiers correspond to local/internal variables created when converting from <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>'s containing mod's and div's; they are thus needed to increase representational power. Each local identifier is always (by construction) a floordiv of a pure add/mul affine function of dimensional, symbolic, and other local identifiers, in a non-mutually recursive way. Hence, every local identifier can ultimately always be recovered as an affine function of dimensional and symbolic identifiers (involving floordiv's); note however that some floordiv combinations are converted to mod's by <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> construction. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab47fbec6c4aff6faece95521b103fed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47fbec6c4aff6faece95521b103fed2">&#9670;&nbsp;</a></span>IdKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">mlir::FlatAffineConstraints::IdKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2a2ee94b4e0a594b0b54351659320e6ba7"></a>Dimension&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2ae3c7272b03244406768692d4fea34372"></a>Symbol&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab47fbec6c4aff6faece95521b103fed2a5cbad5ec78394bb35d4d33f15993f778"></a>Local&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a67d39a02671f878053effe3493e6544a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d39a02671f878053effe3493e6544a">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a constraint system reserving memory for the specified number of constraints and identifiers.. </p>

</div>
</div>
<a id="a2c6c8b02abc69721d025b1ca23db2b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6c8b02abc69721d025b1ca23db2b2e">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a constraint system with the specified number of dimensions and symbols. </p>

</div>
</div>
<a id="a485ccacf0a047233d064351ff31cd9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485ccacf0a047233d064351ff31cd9c1">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const HyperRectangularSet &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ed4103886f4e5761c76b4073aa1de73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed4103886f4e5761c76b4073aa1de73">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>avm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> or a list of these. The constructed system will only include equalities. </p>

</div>
</div>
<a id="a4333c62fce350f020f58b6fb0d2faf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4333c62fce350f020f58b6fb0d2faf0f">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04009cfc4f3c97dbff1cf9594c0f7c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04009cfc4f3c97dbff1cf9594c0f7c9a">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>. </p>

</div>
</div>
<a id="a7947eee63586b73c35a239e63248a9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7947eee63586b73c35a239e63248a9bc">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1IntegerValueSet.html">IntegerValueSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an affine constraint system from an <a class="el" href="classmlir_1_1IntegerValueSet.html" title="An IntegerValueSet is an integer set plus its operands. ">IntegerValueSet</a>. </p>

</div>
</div>
<a id="a4b5f989f74501c929910cc94637209ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5f989f74501c929910cc94637209ce">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af84814b8b20bb9768814270d71952a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84814b8b20bb9768814270d71952a9d">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8074122b77beb705d010169667ae9efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8074122b77beb705d010169667ae9efe">&#9670;&nbsp;</a></span>FlatAffineConstraints() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8824fdedbdc984ff79e3b812016f3b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8824fdedbdc984ff79e3b812016f3b2c">&#9670;&nbsp;</a></span>~FlatAffineConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineConstraints::~FlatAffineConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4150bc63be2852d5efbbd31d1b938a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4150bc63be2852d5efbbd31d1b938a8">&#9670;&nbsp;</a></span>addAffineForOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::addAffineForOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html">Value</a> using IR information stored in its bound maps. The right identifier is first looked up using forOp's <a class="el" href="classmlir_1_1Value.html">Value</a>. Asserts if the <a class="el" href="classmlir_1_1Value.html">Value</a> corresponding to the 'affine.for' operation isn't found in the constraint system. Returns failure for the yet unimplemented/unsupported cases. Any new identifiers that are found in the bound operands of the 'affine.for' operation are added as trailing identifiers (either dimensional or symbolic depending on whether the operand is a valid symbol). </p>

</div>
</div>
<a id="a7876c2038d87d8df799eb8e8010670da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7876c2038d87d8df799eb8e8010670da">&#9670;&nbsp;</a></span>addConstantLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantLowerBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant lower bound constraint for the specified identifier. </p>

</div>
</div>
<a id="a05a6c2a425f192f14a650791fb1154c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a6c2a425f192f14a650791fb1154c3">&#9670;&nbsp;</a></span>addConstantLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantLowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant lower bound constraint for the specified expression. </p>

</div>
</div>
<a id="ae79201460364553813e818c2f4c47b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79201460364553813e818c2f4c47b26">&#9670;&nbsp;</a></span>addConstantUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant upper bound constraint for the specified identifier. </p>

</div>
</div>
<a id="a6023d999d0f85e8c9bf105767991199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6023d999d0f85e8c9bf105767991199a">&#9670;&nbsp;</a></span>addConstantUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addConstantUpperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant upper bound constraint for the specified expression. </p>

</div>
</div>
<a id="a9555bccd54ea166ce653e262797218da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9555bccd54ea166ce653e262797218da">&#9670;&nbsp;</a></span>addDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addDimId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45df72c07b67e459ece93a1076344210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45df72c07b67e459ece93a1076344210">&#9670;&nbsp;</a></span>addEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addEquality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>eq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2faafc96161faad6ec9faf0fb546e4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faafc96161faad6ec9faf0fb546e4ed">&#9670;&nbsp;</a></span>addId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a dimensional identifier. The added column is initialized to zero. </p>

</div>
</div>
<a id="a66c99c8a9d566c1f7fc37671d531c19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c99c8a9d566c1f7fc37671d531c19a">&#9670;&nbsp;</a></span>addInductionVarOrTerminalSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addInductionVarOrTerminalSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system. `id' has to be either a terminal symbol or a loop IV, i.e., it cannot be the result affine.apply of any symbols or loop IVs. The identifier is added to the end of the existing dims or symbols. Additional information on the identifier is extracted from the IR and added to the constraint system. </p>

</div>
</div>
<a id="a9a440a9b51c09ea27d100fb62fb32a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a440a9b51c09ea27d100fb62fb32a7f">&#9670;&nbsp;</a></span>addInequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addInequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>inEq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d81cc0ca235dba7982f6cecc66f2506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d81cc0ca235dba7982f6cecc66f2506">&#9670;&nbsp;</a></span>addLocalFloorDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addLocalFloorDiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in 'dividend' and with respect to a positive constant 'divisor'. Two constraints are added to the system to capture equivalence with the floordiv: q = dividend floordiv c &lt;=&gt; c*q &lt;= dividend &lt;= c*q + c - 1.</p>
<p>Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in 'dividend' and with respect to a positive constant 'divisor'. Two constraints are added to the system to capture equivalence with the floordiv. q = expr floordiv c &lt;=&gt; c*q &lt;= expr &lt;= c*q + c - 1. </p>

</div>
</div>
<a id="a477866201deff5c6a17201fc8669dc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477866201deff5c6a17201fc8669dc15">&#9670;&nbsp;</a></span>addLocalId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addLocalId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a944078deda4fba2b98635152d2759bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944078deda4fba2b98635152d2759bfe">&#9670;&nbsp;</a></span>addLowerOrUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::addLowerOrUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a lower or an upper bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands. If <code>eq</code> is true, add a single equality equal to the bound map's first result expr. </p>

</div>
</div>
<a id="ad5d2543f40e0fc1c4701f20d4b891deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d2543f40e0fc1c4701f20d4b891deb">&#9670;&nbsp;</a></span>addSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::addSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds slice lower bounds represented by lower bounds in 'lbMaps' and upper bounds in 'ubMaps' to each identifier in the constraint system which has a value in 'values'. Note that both lower/upper bounds share the same operand list 'operands'. This function assumes 'values.size' == 'lbMaps.size' == 'ubMaps.size'. Note that both lower/upper bounds use operands from 'operands'. </p>

</div>
</div>
<a id="a7e66197a3e2cc40803abe7cb12685571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e66197a3e2cc40803abe7cb12685571">&#9670;&nbsp;</a></span>addSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::addSymbolId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e4973d2d62dbf7779d1e350fec9911e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4973d2d62dbf7779d1e350fec9911e">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends constraints from 'other' into this. This is equivalent to an intersection with no simplification of any sort attempted. </p>

</div>
</div>
<a id="a86efbe8f7101ca9946ef7978194e0549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86efbe8f7101ca9946ef7978194e0549">&#9670;&nbsp;</a></span>areIdsAlignedWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::areIdsAlignedWithOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns 'true' if this constraint system and 'other' are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order. Returns 'false' otherwise.</p>
<p>Calls areIdsAligned to check if two constraint systems have the same set of identifiers in the same order. </p>

</div>
</div>
<a id="aaeb4c8e8b0bf86fa1609a32bd9028536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb4c8e8b0bf86fa1609a32bd9028536">&#9670;&nbsp;</a></span>atEq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::FlatAffineConstraints::atEq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value at the specified equality row and column. </p>

</div>
</div>
<a id="a0b80ebb1a0929a30c4401d297a420d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b80ebb1a0929a30c4401d297a420d9e">&#9670;&nbsp;</a></span>atEq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t&amp; mlir::FlatAffineConstraints::atEq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a950735c15d0d1757984210922c7118c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950735c15d0d1757984210922c7118c0">&#9670;&nbsp;</a></span>atIneq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::FlatAffineConstraints::atIneq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae02ba9253168af09117779ede6e1020f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02ba9253168af09117779ede6e1020f">&#9670;&nbsp;</a></span>atIneq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t&amp; mlir::FlatAffineConstraints::atIneq </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac662ea0313d9bcac2e44925b6be670e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac662ea0313d9bcac2e44925b6be670e8">&#9670;&nbsp;</a></span>clearAndCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::clearAndCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears this list of constraints and copies other into it. </p>

</div>
</div>
<a id="a4b4985a33143cd113df0f945c2bb6d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4985a33143cd113df0f945c2bb6d8b">&#9670;&nbsp;</a></span>clearConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::clearConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0932fcc3e8ee32f1af944a1f33a9abc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0932fcc3e8ee32f1af944a1f33a9abc3">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt; FlatAffineConstraints::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6350cf623d371e8a91a3a18a08097983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6350cf623d371e8a91a3a18a08097983">&#9670;&nbsp;</a></span>composeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::composeMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>vMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Composes the affine value map with this FlatAffineConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map. Returns failure if the composition fails (when vMap is a semi-affine map). The vMap's operand <a class="el" href="classmlir_1_1Value.html">Value</a>'s are used to look up the right positions in the <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> with which to associate. The dimensional and symbolic operands of vMap should match 1:1 (in the same order) with those of this constraint system, but the latter could have additional trailing operands. </p>

</div>
</div>
<a id="a15f95bfc66876ee75db55381eafbb8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f95bfc66876ee75db55381eafbb8f2">&#9670;&nbsp;</a></span>composeMatchingMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::composeMatchingMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Composes an affine map whose dimensions match one to one to the dimensions of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>. The results of the map 'other' are added as the leading dimensions of this constraint system. Returns failure if 'other' is a semi-affine map. </p>

</div>
</div>
<a id="a00e1041e7db596d628253f1d8d7c8222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e1041e7db596d628253f1d8d7c8222">&#9670;&nbsp;</a></span>constantFoldId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::constantFoldId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system. </p>

</div>
</div>
<a id="ad67b4c81a969b09cf5c4bc723cda93d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b4c81a969b09cf5c4bc723cda93d5">&#9670;&nbsp;</a></span>constantFoldIdRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::constantFoldIdRange </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method calls constantFoldId for the specified range of identifiers, 'num' identifiers starting at position 'pos'. </p>

</div>
</div>
<a id="a5c40a21ee894ea756e84b90a1420d54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c40a21ee894ea756e84b90a1420d54d">&#9670;&nbsp;</a></span>containsId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::containsId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html">Value</a> exists, false otherwise. </p>

</div>
</div>
<a id="a3d00b3e95728c04dfbc98c2907e3b815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d00b3e95728c04dfbc98c2907e3b815">&#9670;&nbsp;</a></span>convertLoopIVSymbolsToDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::convertLoopIVSymbolsToDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all symbol identifiers which are loop IVs to dim identifiers. </p>

</div>
</div>
<a id="a9755c04bef03df1b8130b1a4e76ac605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9755c04bef03df1b8130b1a4e76ac605">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ff9510294db04bfac4065117f27645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ff9510294db04bfac4065117f27645">&#9670;&nbsp;</a></span>findId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::findId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html">Value</a>. Returns true if found (false otherwise). `pos' is set to the (column) position of the identifier. </p>

</div>
</div>
<a id="ae5669e6de739424cd4e46e8cbc4c9b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5669e6de739424cd4e46e8cbc4c9b5f">&#9670;&nbsp;</a></span>getAllIdValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::getAllIdValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a159b9a3d63c5f64c2230e5e661c52217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159b9a3d63c5f64c2230e5e661c52217">&#9670;&nbsp;</a></span>getConstantBoundOnDimSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantBoundOnDimSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>lbFloorDivisor</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>ub</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier. Returns None if it's not a constant. This method employs trivial (low complexity / cost) checks and detection. Symbolic identifiers are treated specially, i.e., it looks for constant differences between affine expressions involving only the symbolic identifiers. See comments at function definition for examples. 'lb' and 'lbDivisor', if provided, are used to express the lower bound associated with the constant difference: 'lb' has the coefficients and lbDivisor, the divisor. For eg., if the lower bound is [(s0 + s2 - 1) floordiv 32] for a system with three symbolic identifiers, *lb = [1, 0, 1], lbDivisor = 32.</p>
<p>Returns the extent (upper bound - lower bound) of the specified identifier if it is found to be a constant; returns None if it's not a constant. This methods treats symbolic identifiers specially, i.e., it looks for constant differences between affine expressions involving only the symbolic identifiers. See comments at function definition for example. 'lb', if provided, is set to the lower bound associated with the constant difference. Note that 'lb' is purely symbolic and thus will contain the coefficients of the symbolic identifiers and the constant coefficient. </p>

</div>
</div>
<a id="ad4a299832c686eb594598d8a61957e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a299832c686eb594598d8a61957e81">&#9670;&nbsp;</a></span>getConstantLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantLowerBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the constant lower bound for the pos^th identifier if there is one; None otherwise. </p>

</div>
</div>
<a id="a908b49c8a201df00af8b924064116c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908b49c8a201df00af8b924064116c19">&#9670;&nbsp;</a></span>getConstantUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; FlatAffineConstraints::getConstantUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the constant upper bound for the pos^th identifier if there is one; None otherwise. </p>

</div>
</div>
<a id="a0673b512906bb0fed9e4c7244f9f0217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0673b512906bb0fed9e4c7244f9f0217">&#9670;&nbsp;</a></span>getEquality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt; mlir::FlatAffineConstraints::getEquality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa36e5e1a5b66abc593cf169bce4b19e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36e5e1a5b66abc593cf169bce4b19e4">&#9670;&nbsp;</a></span>getId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; mlir::FlatAffineConstraints::getId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the optional <a class="el" href="classmlir_1_1Value.html">Value</a> corresponding to the pos^th identifier. </p>

</div>
</div>
<a id="a142fba494ecf189c0decb4f0c5133eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142fba494ecf189c0decb4f0c5133eb8">&#9670;&nbsp;</a></span>getId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;&amp; mlir::FlatAffineConstraints::getId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aacc5592f55bba9543cb957274d145e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc5592f55bba9543cb957274d145e97">&#9670;&nbsp;</a></span>getIds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineConstraints::getIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6df54b69026d3981d00de5ce8e1a4cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df54b69026d3981d00de5ce8e1a4cd4">&#9670;&nbsp;</a></span>getIds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineConstraints::getIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6825cb13390479a204da6d3b1124ff92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6825cb13390479a204da6d3b1124ff92">&#9670;&nbsp;</a></span>getIdValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::FlatAffineConstraints::getIdValue </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="classmlir_1_1Value.html">Value</a> associated with the pos^th identifier. Asserts if no <a class="el" href="classmlir_1_1Value.html">Value</a> identifier was associated. </p>

</div>
</div>
<a id="a181c4aa2ddc90806d2b2f86bb6a91f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181c4aa2ddc90806d2b2f86bb6a91f1a">&#9670;&nbsp;</a></span>getIdValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::getIdValues </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the Values associated with identifiers in range [start, end). Asserts if no <a class="el" href="classmlir_1_1Value.html">Value</a> was associated with one of these identifiers. </p>

</div>
</div>
<a id="a92b9b04e17d80d48a79c0e09710c2be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b9b04e17d80d48a79c0e09710c2be6">&#9670;&nbsp;</a></span>getInequality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;int64_t&gt; mlir::FlatAffineConstraints::getInequality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad0cdbe1cff606a9b364e734ca09dc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cdbe1cff606a9b364e734ca09dc52">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; FlatAffineConstraints::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>symStartPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the lower and upper bound of the pos^th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols. The returned multi-dimensional maps in the pair represent the max and min of potentially multiple affine expressions. The upper bound is exclusive. 'localExprs' holds pre-computed <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>'s for all local identifiers in the system. </p>
<p>Add to 'b' from 'a' in set [0, offset) U [offset + num, symbStartPos). </p>

</div>
</div>
<a id="ad6dafa2401aead0909b87b92d41bfbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dafa2401aead0909b87b92d41bfbbd">&#9670;&nbsp;</a></span>getNumCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in the constraint system. </p>

</div>
</div>
<a id="a747fa3994a809e5994fdc32035b54e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747fa3994a809e5994fdc32035b54e4b">&#9670;&nbsp;</a></span>getNumConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a221a2c98d7a9019f0a93cb1b070152f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221a2c98d7a9019f0a93cb1b070152f3">&#9670;&nbsp;</a></span>getNumDimAndSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumDimAndSymbolIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bb25117553419fb47427704e6c9bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb25117553419fb47427704e6c9bb84">&#9670;&nbsp;</a></span>getNumDimIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumDimIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a963e712e6a344acbadfa413940487704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963e712e6a344acbadfa413940487704">&#9670;&nbsp;</a></span>getNumEqualities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumEqualities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0937c7d6a0a23146fbc6d5caf5e95a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0937c7d6a0a23146fbc6d5caf5e95a8b">&#9670;&nbsp;</a></span>getNumIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50f382f6a3f7062ff36e3dce1920c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f382f6a3f7062ff36e3dce1920c4c9">&#9670;&nbsp;</a></span>getNumInequalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab12365660bdc368e87b6fc73f12e3e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12365660bdc368e87b6fc73f12e3e86">&#9670;&nbsp;</a></span>getNumLocalIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumLocalIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a597e435e789ef833a1e0cc80cd82a388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597e435e789ef833a1e0cc80cd82a388">&#9670;&nbsp;</a></span>getNumReservedEqualities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumReservedEqualities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3617c7a6eef7e4c3d1b1845025900adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3617c7a6eef7e4c3d1b1845025900adf">&#9670;&nbsp;</a></span>getNumReservedInequalities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumReservedInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff8074c726e597eb5a963a68451bb7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8074c726e597eb5a963a68451bb7fe">&#9670;&nbsp;</a></span>getNumSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::FlatAffineConstraints::getNumSymbolIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27fe40151ae13ca4d10c425937ff70f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fe40151ae13ca4d10c425937ff70f2">&#9670;&nbsp;</a></span>getSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::getSliceBounds </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *&#160;</td>
          <td class="paramname"><em>ubMaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the lower and upper bounds of the first 'num' dimensional identifiers (starting at 'offset') as an affine map of the remaining identifiers (dimensional and symbolic). This method is able to detect identifiers as floordiv's and mod's of affine expressions of other identifiers with respect to (positive) constants. Sets bound map to a null <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> if such a bound can't be found (or yet unimplemented).</p>
<p>Computes the lower and upper bounds of the first 'num' dimensional identifiers (starting at 'offset') as affine maps of the remaining identifiers (dimensional and symbolic identifiers). Local identifiers are themselves explicitly computed as affine functions of other identifiers in this process if needed. </p>

</div>
</div>
<a id="a6ddc2ce92fc0297fbc8bfc62241c4472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddc2ce92fc0297fbc8bfc62241c4472">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af318337e58529a47cd9c9e38e11b3e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af318337e58529a47cd9c9e38e11b3e67">&#9670;&nbsp;</a></span>isEmptyByGCDTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isEmptyByGCDTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa635e50de116843fba9c4d6213ce14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa635e50de116843fba9c4d6213ce14c">&#9670;&nbsp;</a></span>isHyperRectangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineConstraints::isHyperRectangular </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers. </p>

</div>
</div>
<a id="a60f6511f180daae3af295023e7b45336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f6511f180daae3af295023e7b45336">&#9670;&nbsp;</a></span>mergeAndAlignIdsWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::mergeAndAlignIdsWithOther </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge and align the identifiers of 'this' and 'other' starting at 'offset', so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with this's original identifiers appearing first followed by any of other's identifiers that didn't appear in 'this'. Local identifiers of each system are by design separate/local and are placed one after other (this's followed by other's). </p>

</div>
</div>
<a id="a32f2f50452ba560992138f6df070045e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f2f50452ba560992138f6df070045e">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63d1457dc3d54274c1519c6553be921d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d1457dc3d54274c1519c6553be921d">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects out (aka eliminates) 'num' identifiers starting at position 'pos'. The resulting constraint system is the shadow along the dimensions that still exist. This method may not always be integer exact. </p>

</div>
</div>
<a id="a8c3d0c1b0bad5d54e4b5f91910c52503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3d0c1b0bad5d54e4b5f91910c52503">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49f74eab80eb71234f457d296716dbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f74eab80eb71234f457d296716dbec">&#9670;&nbsp;</a></span>projectOut() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html">Value</a> . </p>

</div>
</div>
<a id="a282561f245c5a8ba5b8467af590d80f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282561f245c5a8ba5b8467af590d80f8">&#9670;&nbsp;</a></span>removeDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::removeDim </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3d4894b1c67f1e06424e1453c585bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d4894b1c67f1e06424e1453c585bbf">&#9670;&nbsp;</a></span>removeEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeEquality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74219ea7114c7c5ddec36845a7369f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74219ea7114c7c5ddec36845a7369f6f">&#9670;&nbsp;</a></span>removeId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::removeId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab47fbec6c4aff6faece95521b103fed2">IdKind</a>&#160;</td>
          <td class="paramname"><em>idKind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7e3fb602c03ba136b94b31a58bca727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e3fb602c03ba136b94b31a58bca727">&#9670;&nbsp;</a></span>removeId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab21e6041df1c8414405c512d50a0da54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21e6041df1c8414405c512d50a0da54">&#9670;&nbsp;</a></span>removeInequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::removeInequality </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60b9abcf1ae4683b7ed214125d4d05c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b9abcf1ae4683b7ed214125d4d05c8">&#9670;&nbsp;</a></span>removeRedundantInequalities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeRedundantInequalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A more expensive check to detect redundant inequalities thatn removeTrivialRedundancy. </p>

</div>
</div>
<a id="ab3a710d4a8812b2e76eb3908a5767dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a710d4a8812b2e76eb3908a5767dac">&#9670;&nbsp;</a></span>removeTrivialRedundancy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::removeTrivialRedundancy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part. A constraint of the form &lt;non-negative constant&gt; &gt;= 0 is considered trivially true. This method is a linear time method on the constraints, does a single scan, and updates in place.</p>
<p>Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part. A constraint of the form &lt;non-negative constant&gt; &gt;= 0 is considered trivially true. </p>

</div>
</div>
<a id="afb5165263cbbc9080ca858b235f98cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5165263cbbc9080ca858b235f98cd7">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0cc51d0f0dc264158dd9fd0bb47cd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cc51d0f0dc264158dd9fd0bb47cd28">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>idArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a201799397e672780c6bce3674f969f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201799397e672780c6bce3674f969f3b">&#9670;&nbsp;</a></span>setAndEliminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setAndEliminate </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified identifier to a constant and removes it. </p>

</div>
</div>
<a id="ad4924b4c54d6823f8e52933ca960c1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4924b4c54d6823f8e52933ca960c1ff">&#9670;&nbsp;</a></span>setDimSymbolSeparation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setDimSymbolSeparation </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>newSymbolCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the partition between dimensions and symbols. Depending on the new symbol count, either a chunk of trailing dimensional identifiers becomes symbols, or some of the leading symbols become dimensions. </p>

</div>
</div>
<a id="a06e4c5fcf51e01bf82d9d82a26ff316a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e4c5fcf51e01bf82d9d82a26ff316a">&#9670;&nbsp;</a></span>setIdToConstant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setIdToConstant </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the identifier at the specified position to a constant. </p>
<p>Sets the specified identifier to a constant value. </p>

</div>
</div>
<a id="a04dee3803932dd1553f52b71f0372b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dee3803932dd1553f52b71f0372b12">&#9670;&nbsp;</a></span>setIdToConstant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlatAffineConstraints::setIdToConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the identifier corresponding to the specified <a class="el" href="classmlir_1_1Value.html">Value</a> id to a constant. Asserts if the 'id' is not found.</p>
<p>Sets the specified identifier to a constant value; asserts if the id is not found. </p>

</div>
</div>
<a id="a77ff33d7c48f5d8de4f26b95f2a94034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ff33d7c48f5d8de4f26b95f2a94034">&#9670;&nbsp;</a></span>setIdValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::setIdValue </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classmlir_1_1Value.html">Value</a> associated with the pos^th identifier. </p>

</div>
</div>
<a id="a8bda84f68040789ebf27848f7bcaa169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bda84f68040789ebf27848f7bcaa169">&#9670;&nbsp;</a></span>setIdValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::FlatAffineConstraints::setIdValues </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets Values associated with identifiers in the range [start, end). </p>

</div>
</div>
<a id="a3713af3279fc39f3630a5a6b89031653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3713af3279fc39f3630a5a6b89031653">&#9670;&nbsp;</a></span>toAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::FlatAffineConstraints::toAffineExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afeb8348eba3bd5c81db503336ae2ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8348eba3bd5c81db503336ae2ebfc">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineConstraints::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the constraints to be the smallest bounding (enclosing) box that contains the points of 'this' set and that of 'other', with the symbols being treated specially. For each of the dimensions, the min of the lower bounds (symbolic) and the max of the upper bounds (symbolic) is computed to determine such a bounding box. `other' is expected to have the same dimensional identifiers as this constraint system (in the same order).</p>
<p>Eg: if 'this' is {0 &lt;= d0 &lt;= 127}, 'other' is {16 &lt;= d0 &lt;= 192}, the output is {0 &lt;= d0 &lt;= 192}. 2) 'this' = {s0 + 5 &lt;= d0 &lt;= s0 + 20}, 'other' is {s0 + 1 &lt;= d0 &lt;= s0 + 9}, output = {s0 + 1 &lt;= d0 &lt;= s0 + 20}. 3) 'this' = {0 &lt;= d0 &lt;= 5, 1 &lt;= d1 &lt;= 9}, 'other' = {2 &lt;= d0 &lt;= 6, 5 &lt;= d1 &lt;= 15}, output = {0 &lt;= d0 &lt;= 6, 1 &lt;= d1 &lt;= 15}. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Analysis/<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a></li>
<li>lib/Analysis/<a class="el" href="AffineStructures_8cpp.html">AffineStructures.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
