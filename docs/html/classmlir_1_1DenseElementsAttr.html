<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: mlir::DenseElementsAttr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classmlir_1_1DenseElementsAttr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::DenseElementsAttr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Attributes_8h_source.html">Attributes.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::DenseElementsAttr:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1DenseElementsAttr__inherit__graph.png" border="0" usemap="#mlir_1_1DenseElementsAttr_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1DenseElementsAttr_inherit__map" id="mlir_1_1DenseElementsAttr_inherit__map">
<area shape="rect" id="node4" href="classmlir_1_1DenseFPElementsAttr.html" title="mlir::DenseFPElementsAttr" alt="" coords="604,5,787,32"/>
<area shape="rect" id="node5" href="classmlir_1_1DenseIntElementsAttr.html" title="mlir::DenseIntElementsAttr" alt="" coords="605,56,785,83"/>
<area shape="rect" id="node6" href="classmlir_1_1SplatElementsAttr.html" title="mlir::SplatElementsAttr" alt="" coords="617,107,774,133"/>
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1StorageUserBase.html" title="Attribute::AttrBase\l\&lt; DenseElementsAttr,\l ElementsAttr, detail\l::DenseElementsAttributeStorage \&gt;" alt="" coords="113,34,343,105"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::DenseElementsAttr:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1DenseElementsAttr__coll__graph.png" border="0" usemap="#mlir_1_1DenseElementsAttr_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1DenseElementsAttr_coll__map" id="mlir_1_1DenseElementsAttr_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1StorageUserBase.html" title="Attribute::AttrBase\l\&lt; DenseElementsAttr,\l ElementsAttr, detail\l::DenseElementsAttributeStorage \&gt;" alt="" coords="113,5,343,76"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html">BoolElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that allows walking over the internal bool values.  <a href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for walking over APFloat values.  <a href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that allows walking over the internal raw APInt values.  <a href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af27156ea57a7722ba5b6908ec603e046"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af27156ea57a7722ba5b6908ec603e046"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#af27156ea57a7722ba5b6908ec603e046">DerivedAttributeElementIterator</a> = llvm::mapped_iterator&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a>, T(*)(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td></tr>
<tr class="separator:af27156ea57a7722ba5b6908ec603e046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;</a></td></tr>
<tr class="memitem:a266df0a1f2b53b4ac4bbed1a86ab5ea4 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a266df0a1f2b53b4ac4bbed1a86ab5ea4">Base</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">StorageUserBase</a>&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;</td></tr>
<tr class="memdesc:a266df0a1f2b53b4ac4bbed1a86ab5ea4 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility declarations for the concrete attribute class.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a266df0a1f2b53b4ac4bbed1a86ab5ea4">More...</a><br /></td></tr>
<tr class="separator:a266df0a1f2b53b4ac4bbed1a86ab5ea4 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6c091aef321e81e6eb124c84a464e0 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#aab6c091aef321e81e6eb124c84a464e0">ImplType</a> = StorageT</td></tr>
<tr class="separator:aab6c091aef321e81e6eb124c84a464e0 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a415aaf672c2a9a8559335b29c31284"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5a415aaf672c2a9a8559335b29c31284">isSplat</a> () const</td></tr>
<tr class="separator:a5a415aaf672c2a9a8559335b29c31284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74365cf47dc7033c406a10f47c291aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a74365cf47dc7033c406a10f47c291aee">getSplatValue</a> () const</td></tr>
<tr class="separator:a74365cf47dc7033c406a10f47c291aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49be83cff03233289860200183e528f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49be83cff03233289860200183e528f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value||std::is_same&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a49be83cff03233289860200183e528f7">getSplatValue</a> () const</td></tr>
<tr class="separator:a49be83cff03233289860200183e528f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349b5b5145789ea2d2b183f860893318"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a349b5b5145789ea2d2b183f860893318"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a349b5b5145789ea2d2b183f860893318">getSplatValue</a> () const</td></tr>
<tr class="memdesc:a349b5b5145789ea2d2b183f860893318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the splat value for derived attribute element types.  <a href="#a349b5b5145789ea2d2b183f860893318">More...</a><br /></td></tr>
<tr class="separator:a349b5b5145789ea2d2b183f860893318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eabf123a7cbf1cc9b1a76e6f4c7c55e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a2eabf123a7cbf1cc9b1a76e6f4c7c55e">getValue</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; index) const</td></tr>
<tr class="separator:a2eabf123a7cbf1cc9b1a76e6f4c7c55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e4d2beb2cb1606d9ad6eb0cc48cac3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a29e4d2beb2cb1606d9ad6eb0cc48cac3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a29e4d2beb2cb1606d9ad6eb0cc48cac3">getValue</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; index) const</td></tr>
<tr class="separator:a29e4d2beb2cb1606d9ad6eb0cc48cac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7bb7314fd7fcb4446cc173d8e069c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            (!std::is_same&lt;T, bool&gt;::value &amp;&amp;                             std::numeric_limits&lt;T&gt;::is_integer) ||                            llvm::is_one_of&lt;T, float, double&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a8d7bb7314fd7fcb4446cc173d8e069c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a8d7bb7314fd7fcb4446cc173d8e069c7">getValues</a> () const</td></tr>
<tr class="separator:a8d7bb7314fd7fcb4446cc173d8e069c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab44751a072ecb13c554924c506b993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6ab44751a072ecb13c554924c506b993">getAttributeValues</a> () const</td></tr>
<tr class="memdesc:a6ab44751a072ecb13c554924c506b993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the held element values as a range of Attributes.  <a href="#a6ab44751a072ecb13c554924c506b993">More...</a><br /></td></tr>
<tr class="separator:a6ab44751a072ecb13c554924c506b993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa8544c71b5bb685c2ddaccf2703c56"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, Attribute&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6fa8544c71b5bb685c2ddaccf2703c56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6fa8544c71b5bb685c2ddaccf2703c56">getValues</a> () const</td></tr>
<tr class="separator:a6fa8544c71b5bb685c2ddaccf2703c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49cd4ca06d02c89b727800db3ec8bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ac49cd4ca06d02c89b727800db3ec8bdd">attr_value_begin</a> () const</td></tr>
<tr class="separator:ac49cd4ca06d02c89b727800db3ec8bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbf255b96f444f6b233c29ecd6ab3cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a4cbf255b96f444f6b233c29ecd6ab3cd">attr_value_end</a> () const</td></tr>
<tr class="separator:a4cbf255b96f444f6b233c29ecd6ab3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0141afa608349563fe86db7a9662ce3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_base_of&lt;Attribute, T&gt;::value &amp;&amp;                            !std::is_same&lt;Attribute, T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0141afa608349563fe86db7a9662ce3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr.html#af27156ea57a7722ba5b6908ec603e046">DerivedAttributeElementIterator</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a0141afa608349563fe86db7a9662ce3a">getValues</a> () const</td></tr>
<tr class="separator:a0141afa608349563fe86db7a9662ce3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b4aa9eb5bce0a7a6ba3d8c67d19749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html">BoolElementIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ac6b4aa9eb5bce0a7a6ba3d8c67d19749">getBoolValues</a> () const</td></tr>
<tr class="separator:ac6b4aa9eb5bce0a7a6ba3d8c67d19749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd41d2a6ba96e003105067ce7d9cea6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, bool&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:acd41d2a6ba96e003105067ce7d9cea6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html">BoolElementIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#acd41d2a6ba96e003105067ce7d9cea6a">getValues</a> () const</td></tr>
<tr class="separator:acd41d2a6ba96e003105067ce7d9cea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4b74e0a4ceb4b586df550e80f512c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#acf4b74e0a4ceb4b586df550e80f512c5">getIntValues</a> () const</td></tr>
<tr class="separator:acf4b74e0a4ceb4b586df550e80f512c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ef3b01237a907f9dfd93307a37b5f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, APInt&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a630ef3b01237a907f9dfd93307a37b5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a630ef3b01237a907f9dfd93307a37b5f">getValues</a> () const</td></tr>
<tr class="separator:a630ef3b01237a907f9dfd93307a37b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465f154eb11d3fd5524b20856a06f620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a465f154eb11d3fd5524b20856a06f620">int_value_begin</a> () const</td></tr>
<tr class="separator:a465f154eb11d3fd5524b20856a06f620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8253f8abd8667c082a6c52255bebd37a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a8253f8abd8667c082a6c52255bebd37a">int_value_end</a> () const</td></tr>
<tr class="separator:a8253f8abd8667c082a6c52255bebd37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313c574a55d6c15128bf72a73cf21772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a313c574a55d6c15128bf72a73cf21772">getFloatValues</a> () const</td></tr>
<tr class="separator:a313c574a55d6c15128bf72a73cf21772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290732a3ff9349620717efbc3c60ab8a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, APFloat&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a290732a3ff9349620717efbc3c60ab8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt; <a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a290732a3ff9349620717efbc3c60ab8a">getValues</a> () const</td></tr>
<tr class="separator:a290732a3ff9349620717efbc3c60ab8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0df03cf9ba74e4070de4ad7c8117f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#acd0df03cf9ba74e4070de4ad7c8117f0">float_value_begin</a> () const</td></tr>
<tr class="separator:acd0df03cf9ba74e4070de4ad7c8117f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad582eb57ac32baa86f45b458da9aa6a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ad582eb57ac32baa86f45b458da9aa6a8">float_value_end</a> () const</td></tr>
<tr class="separator:ad582eb57ac32baa86f45b458da9aa6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09e89266a795b6620886950bf0c6494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ac09e89266a795b6620886950bf0c6494">reshape</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> newType)</td></tr>
<tr class="separator:ac09e89266a795b6620886950bf0c6494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba5d17627aea7a53baa138bb63d1c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a71ba5d17627aea7a53baa138bb63d1c9">mapValues</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> newElementType, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APInt &amp;)&gt; mapping) const</td></tr>
<tr class="separator:a71ba5d17627aea7a53baa138bb63d1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f171c2c466569cb71f70004846ec478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a1f171c2c466569cb71f70004846ec478">mapValues</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> newElementType, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APFloat &amp;)&gt; mapping) const</td></tr>
<tr class="separator:a1f171c2c466569cb71f70004846ec478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae5d2311384459ea19a61c29c10aa3353"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#ae5d2311384459ea19a61c29c10aa3353">classof</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:ae5d2311384459ea19a61c29c10aa3353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for support type inquiry through isa, cast and dyn_cast.  <a href="#ae5d2311384459ea19a61c29c10aa3353">More...</a><br /></td></tr>
<tr class="separator:ae5d2311384459ea19a61c29c10aa3353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51b516164da8fa942cb0ec3c0a7f3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a8e51b516164da8fa942cb0ec3c0a7f3e">get</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; values)</td></tr>
<tr class="separator:a8e51b516164da8fa942cb0ec3c0a7f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd07741e5976d7768d65a5613e0cb36"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            std::numeric_limits&lt;T&gt;::is_integer ||                            llvm::is_one_of&lt;T, float, double&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6fd07741e5976d7768d65a5613e0cb36"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6fd07741e5976d7768d65a5613e0cb36">get</a> (const <a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> &amp;type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt; values)</td></tr>
<tr class="separator:a6fd07741e5976d7768d65a5613e0cb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8976a7140578a7553fec2afc678c13"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;                            std::numeric_limits&lt;T&gt;::is_integer ||                            llvm::is_one_of&lt;T, float, double&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aae8976a7140578a7553fec2afc678c13"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#aae8976a7140578a7553fec2afc678c13">get</a> (const <a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> &amp;type, T value)</td></tr>
<tr class="memdesc:aae8976a7140578a7553fec2afc678c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a dense integer elements attribute from a single element.  <a href="#aae8976a7140578a7553fec2afc678c13">More...</a><br /></td></tr>
<tr class="separator:aae8976a7140578a7553fec2afc678c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7ef288cc0b46b2bd383eea70e18da8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5c7ef288cc0b46b2bd383eea70e18da8">get</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; values)</td></tr>
<tr class="memdesc:a5c7ef288cc0b46b2bd383eea70e18da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the above 'get' method that is specialized for boolean values.  <a href="#a5c7ef288cc0b46b2bd383eea70e18da8">More...</a><br /></td></tr>
<tr class="separator:a5c7ef288cc0b46b2bd383eea70e18da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea3b823f2902e8c7a070b69f1c9c2c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a5ea3b823f2902e8c7a070b69f1c9c2c7">get</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APInt &gt; values)</td></tr>
<tr class="separator:a5ea3b823f2902e8c7a070b69f1c9c2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88cee592a4002325ca21c1e3b5dd2e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#af88cee592a4002325ca21c1e3b5dd2e6">get</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APFloat &gt; values)</td></tr>
<tr class="separator:af88cee592a4002325ca21c1e3b5dd2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d306b90bf720ebe6f36c0714ee9bb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74d306b90bf720ebe6f36c0714ee9bb5"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a74d306b90bf720ebe6f36c0714ee9bb5">get</a> (const <a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> &amp;type, const std::initializer_list&lt; T &gt; &amp;list)</td></tr>
<tr class="separator:a74d306b90bf720ebe6f36c0714ee9bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;</a></td></tr>
<tr class="memitem:af1a2f68d4f2d655558a4bc72a2973ae7 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1ClassID.html">ClassID</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#af1a2f68d4f2d655558a4bc72a2973ae7">getClassID</a> ()</td></tr>
<tr class="memdesc:af1a2f68d4f2d655558a4bc72a2973ae7 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete type.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#af1a2f68d4f2d655558a4bc72a2973ae7">More...</a><br /></td></tr>
<tr class="separator:af1a2f68d4f2d655558a4bc72a2973ae7 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f81bf19967da794a4c4449b63f335f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41f81bf19967da794a4c4449b63f335f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a41f81bf19967da794a4c4449b63f335f">classof</a> (T val)</td></tr>
<tr class="separator:a41f81bf19967da794a4c4449b63f335f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6814d418f6b952cd05a1fec9ca35ca0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a6814d418f6b952cd05a1fec9ca35ca0b">getRawData</a> () const</td></tr>
<tr class="memdesc:a6814d418f6b952cd05a1fec9ca35ca0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the raw storage data held by this attribute.  <a href="#a6814d418f6b952cd05a1fec9ca35ca0b">More...</a><br /></td></tr>
<tr class="separator:a6814d418f6b952cd05a1fec9ca35ca0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fbc2ca37e1bbfa30550c0becd8edd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a11fbc2ca37e1bbfa30550c0becd8edd1">raw_int_begin</a> () const</td></tr>
<tr class="memdesc:a11fbc2ca37e1bbfa30550c0becd8edd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterators to the raw APInt values for each element in this attribute.  <a href="#a11fbc2ca37e1bbfa30550c0becd8edd1">More...</a><br /></td></tr>
<tr class="separator:a11fbc2ca37e1bbfa30550c0becd8edd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8777e4250a1fefb04eb82cfcfa5c9161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a8777e4250a1fefb04eb82cfcfa5c9161">raw_int_end</a> () const</td></tr>
<tr class="separator:a8777e4250a1fefb04eb82cfcfa5c9161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3f31374f104acb69862832a6b1b3f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a7a3f31374f104acb69862832a6b1b3f9">isValidIntOrFloat</a> (int64_t dataEltSize, bool isInt) const</td></tr>
<tr class="separator:a7a3f31374f104acb69862832a6b1b3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;</a></td></tr>
<tr class="memitem:af9f5e7cdf1baebce6f7690c51c9ca143 inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#aab6c091aef321e81e6eb124c84a464e0">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#af9f5e7cdf1baebce6f7690c51c9ca143">getImpl</a> () const</td></tr>
<tr class="memdesc:af9f5e7cdf1baebce6f7690c51c9ca143 inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for easy access to the storage instance.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#af9f5e7cdf1baebce6f7690c51c9ca143">More...</a><br /></td></tr>
<tr class="separator:af9f5e7cdf1baebce6f7690c51c9ca143 inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a38be25f060c26d2f7e55965be7eef886"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a38be25f060c26d2f7e55965be7eef886">getRaw</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APInt &gt; values)</td></tr>
<tr class="separator:a38be25f060c26d2f7e55965be7eef886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348088030081cd5b656c8ad5dcf581bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#a348088030081cd5b656c8ad5dcf581bf">getRaw</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; data, bool <a class="el" href="classmlir_1_1DenseElementsAttr.html#a5a415aaf672c2a9a8559335b29c31284">isSplat</a>)</td></tr>
<tr class="separator:a348088030081cd5b656c8ad5dcf581bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2de041aadc850348185a5c8e33a2aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html#acb2de041aadc850348185a5c8e33a2aa">getRawIntOrFloat</a> (<a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; data, int64_t dataEltSize, bool isInt)</td></tr>
<tr class="separator:acb2de041aadc850348185a5c8e33a2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;</a></td></tr>
<tr class="memitem:a6ee6987fa155c547771c77a4680e320a inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6ee6987fa155c547771c77a4680e320a inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a6ee6987fa155c547771c77a4680e320a">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, unsigned kind, Args... args)</td></tr>
<tr class="separator:a6ee6987fa155c547771c77a4680e320a inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e2c83d25ab81e2eaebac5b73690888 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a57e2c83d25ab81e2eaebac5b73690888 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a57e2c83d25ab81e2eaebac5b73690888">getChecked</a> (const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, unsigned kind, Args... args)</td></tr>
<tr class="separator:a57e2c83d25ab81e2eaebac5b73690888 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978ed970a11ae2c1eeb50bfb672516b8 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a978ed970a11ae2c1eeb50bfb672516b8 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a978ed970a11ae2c1eeb50bfb672516b8">verifyConstructionInvariants</a> (Args... args)</td></tr>
<tr class="memdesc:a978ed970a11ae2c1eeb50bfb672516b8 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation that just returns success.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a978ed970a11ae2c1eeb50bfb672516b8">More...</a><br /></td></tr>
<tr class="separator:a978ed970a11ae2c1eeb50bfb672516b8 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An attribute that represents a reference to a dense vector or tensor object. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af27156ea57a7722ba5b6908ec603e046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27156ea57a7722ba5b6908ec603e046">&#9670;&nbsp;</a></span>DerivedAttributeElementIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1DenseElementsAttr.html#af27156ea57a7722ba5b6908ec603e046">mlir::DenseElementsAttr::DerivedAttributeElementIterator</a> =  llvm::mapped_iterator&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a>, T (*)(<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the held element values a range of T, where T is a derived attribute type. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac49cd4ca06d02c89b727800db3ec8bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49cd4ca06d02c89b727800db3ec8bdd">&#9670;&nbsp;</a></span>attr_value_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::attr_value_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cbf255b96f444f6b233c29ecd6ab3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbf255b96f444f6b233c29ecd6ab3cd">&#9670;&nbsp;</a></span>attr_value_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::attr_value_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5d2311384459ea19a61c29c10aa3353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d2311384459ea19a61c29c10aa3353">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::DenseElementsAttr::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method for support type inquiry through isa, cast and dyn_cast. </p>

</div>
</div>
<a id="acd0df03cf9ba74e4070de4ad7c8117f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0df03cf9ba74e4070de4ad7c8117f0">&#9670;&nbsp;</a></span>float_value_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::float_value_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad582eb57ac32baa86f45b458da9aa6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad582eb57ac32baa86f45b458da9aa6a8">&#9670;&nbsp;</a></span>float_value_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::float_value_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e51b516164da8fa942cb0ec3c0a7f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e51b516164da8fa942cb0ec3c0a7f3e">&#9670;&nbsp;</a></span>get() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a dense elements attribute from an array of element values. Each element attribute value is expected to be an element of 'type'. 'type' must be a vector or tensor with static shape. </p>

</div>
</div>
<a id="a6fd07741e5976d7768d65a5613e0cb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd07741e5976d7768d65a5613e0cb36">&#9670;&nbsp;</a></span>get() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            std::numeric_limits&lt;T&gt;::is_integer ||                            llvm::is_one_of&lt;T, float, double&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> mlir::DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a dense integer elements attribute from an array of integer or floating-point values. Each value is expected to be the same bitwidth of the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

</div>
</div>
<a id="aae8976a7140578a7553fec2afc678c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8976a7140578a7553fec2afc678c13">&#9670;&nbsp;</a></span>get() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            std::numeric_limits&lt;T&gt;::is_integer ||                            llvm::is_one_of&lt;T, float, double&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> mlir::DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a dense integer elements attribute from a single element. </p>

</div>
</div>
<a id="a5c7ef288cc0b46b2bd383eea70e18da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7ef288cc0b46b2bd383eea70e18da8">&#9670;&nbsp;</a></span>get() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the above 'get' method that is specialized for boolean values. </p>

</div>
</div>
<a id="a5ea3b823f2902e8c7a070b69f1c9c2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea3b823f2902e8c7a070b69f1c9c2c7">&#9670;&nbsp;</a></span>get() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APInt &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a dense integer elements attribute from an array of APInt values. Each APInt value is expected to have the same bitwidth as the element type of 'type'. 'type' must be a vector or tensor with static shape.</p>
<p>Constructs a dense integer elements attribute from an array of APInt values. Each APInt value is expected to have the same bitwidth as the element type of 'type'. </p>

</div>
</div>
<a id="af88cee592a4002325ca21c1e3b5dd2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88cee592a4002325ca21c1e3b5dd2e6">&#9670;&nbsp;</a></span>get() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APFloat &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a dense float elements attribute from an array of APFloat values. Each APFloat value is expected to have the same bitwidth as the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

</div>
</div>
<a id="a74d306b90bf720ebe6f36c0714ee9bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d306b90bf720ebe6f36c0714ee9bb5">&#9670;&nbsp;</a></span>get() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> mlir::DenseElementsAttr::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a dense elements attribute for an initializer_list of values. Each value is expected to be the same bitwidth of the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

</div>
</div>
<a id="a6ab44751a072ecb13c554924c506b993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab44751a072ecb13c554924c506b993">&#9670;&nbsp;</a></span>getAttributeValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::getAttributeValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the held element values as a range of Attributes. </p>

</div>
</div>
<a id="ac6b4aa9eb5bce0a7a6ba3d8c67d19749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b4aa9eb5bce0a7a6ba3d8c67d19749">&#9670;&nbsp;</a></span>getBoolValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::getBoolValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the held element values as a range of bool. The element type of this attribute must be of integer type of bitwidth 1. </p>

</div>
</div>
<a id="a313c574a55d6c15128bf72a73cf21772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313c574a55d6c15128bf72a73cf21772">&#9670;&nbsp;</a></span>getFloatValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::getFloatValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the held element values as a range of APFloat. The element type of this attribute must be of float type. </p>

</div>
</div>
<a id="acf4b74e0a4ceb4b586df550e80f512c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4b74e0a4ceb4b586df550e80f512c5">&#9670;&nbsp;</a></span>getIntValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::getIntValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the held element values as a range of APInts. The element type of this attribute must be of integer type. </p>

</div>
</div>
<a id="a38be25f060c26d2f7e55965be7eef886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38be25f060c26d2f7e55965be7eef886">&#9670;&nbsp;</a></span>getRaw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::getRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; APInt &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a dense elements attribute from an array of raw APInt values. Each APInt value is expected to have the same bitwidth as the element type of 'type'. 'type' must be a vector or tensor with static shape. </p>

</div>
</div>
<a id="a348088030081cd5b656c8ad5dcf581bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348088030081cd5b656c8ad5dcf581bf">&#9670;&nbsp;</a></span>getRaw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::getRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSplat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get or create a new dense elements attribute instance with the given raw data buffer. 'type' must be a vector or tensor with static shape. </p>

</div>
</div>
<a id="a6814d418f6b952cd05a1fec9ca35ca0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6814d418f6b952cd05a1fec9ca35ca0b">&#9670;&nbsp;</a></span>getRawData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt; DenseElementsAttr::getRawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the raw storage data held by this attribute. </p>

</div>
</div>
<a id="acb2de041aadc850348185a5c8e33a2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2de041aadc850348185a5c8e33a2aa">&#9670;&nbsp;</a></span>getRawIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::getRawIntOrFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dataEltSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload of the raw 'get' method that asserts that the given type is of integer or floating-point type. This method is used to verify type invariants that the templatized 'get' method cannot.</p>
<p>Overload of the 'getRaw' method that asserts that the given type is of integer type. This method is used to verify type invariants that the templatized 'get' method cannot. </p>

</div>
</div>
<a id="a74365cf47dc7033c406a10f47c291aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74365cf47dc7033c406a10f47c291aee">&#9670;&nbsp;</a></span>getSplatValue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::DenseElementsAttr::getSplatValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the splat value for this attribute. This asserts that the attribute corresponds to a splat. </p>

</div>
</div>
<a id="a49be83cff03233289860200183e528f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49be83cff03233289860200183e528f7">&#9670;&nbsp;</a></span>getSplatValue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value || std::is_same&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value, T&gt;::type mlir::DenseElementsAttr::getSplatValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a349b5b5145789ea2d2b183f860893318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349b5b5145789ea2d2b183f860893318">&#9670;&nbsp;</a></span>getSplatValue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value &amp;&amp; !std::is_same&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>, T&gt;::value, T&gt;::type mlir::DenseElementsAttr::getSplatValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the splat value for derived attribute element types. </p>

</div>
</div>
<a id="a2eabf123a7cbf1cc9b1a76e6f4c7c55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eabf123a7cbf1cc9b1a76e6f4c7c55e">&#9670;&nbsp;</a></span>getValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::DenseElementsAttr::getValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value at the given index. The 'index' is expected to refer to a valid element. </p>

</div>
</div>
<a id="a29e4d2beb2cb1606d9ad6eb0cc48cac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e4d2beb2cb1606d9ad6eb0cc48cac3">&#9670;&nbsp;</a></span>getValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T mlir::DenseElementsAttr::getValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7bb7314fd7fcb4446cc173d8e069c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7bb7314fd7fcb4446cc173d8e069c7">&#9670;&nbsp;</a></span>getValues() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            (!std::is_same&lt;T, bool&gt;::value &amp;&amp;                             std::numeric_limits&lt;T&gt;::is_integer) ||                            llvm::is_one_of&lt;T, float, double&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1ElementIterator.html">ElementIterator</a>&lt;T&gt; &gt; mlir::DenseElementsAttr::getValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the held element values as a range of integer or floating-point values. </p>

</div>
</div>
<a id="a6fa8544c71b5bb685c2ddaccf2703c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa8544c71b5bb685c2ddaccf2703c56">&#9670;&nbsp;</a></span>getValues() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, Attribute&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1AttributeElementIterator.html">AttributeElementIterator</a>&gt; mlir::DenseElementsAttr::getValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0141afa608349563fe86db7a9662ce3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0141afa608349563fe86db7a9662ce3a">&#9670;&nbsp;</a></span>getValues() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_base_of&lt;Attribute, T&gt;::value &amp;&amp;                            !std::is_same&lt;Attribute, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr.html#af27156ea57a7722ba5b6908ec603e046">DerivedAttributeElementIterator</a>&lt;T&gt; &gt; mlir::DenseElementsAttr::getValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd41d2a6ba96e003105067ce7d9cea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd41d2a6ba96e003105067ce7d9cea6a">&#9670;&nbsp;</a></span>getValues() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, bool&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1BoolElementIterator.html">BoolElementIterator</a>&gt; mlir::DenseElementsAttr::getValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a630ef3b01237a907f9dfd93307a37b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ef3b01237a907f9dfd93307a37b5f">&#9670;&nbsp;</a></span>getValues() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, APInt&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a>&gt; mlir::DenseElementsAttr::getValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a290732a3ff9349620717efbc3c60ab8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290732a3ff9349620717efbc3c60ab8a">&#9670;&nbsp;</a></span>getValues() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;                            std::is_same&lt;T, APFloat&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1iterator__range.html">llvm::iterator_range</a>&lt;<a class="el" href="classmlir_1_1DenseElementsAttr_1_1FloatElementIterator.html">FloatElementIterator</a>&gt; mlir::DenseElementsAttr::getValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a465f154eb11d3fd5524b20856a06f620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465f154eb11d3fd5524b20856a06f620">&#9670;&nbsp;</a></span>int_value_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::int_value_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8253f8abd8667c082a6c52255bebd37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8253f8abd8667c082a6c52255bebd37a">&#9670;&nbsp;</a></span>int_value_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto DenseElementsAttr::int_value_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a415aaf672c2a9a8559335b29c31284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a415aaf672c2a9a8559335b29c31284">&#9670;&nbsp;</a></span>isSplat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DenseElementsAttr::isSplat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if this attribute corresponds to a splat, i.e. if all element values are the same. </p>

</div>
</div>
<a id="a7a3f31374f104acb69862832a6b1b3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3f31374f104acb69862832a6b1b3f9">&#9670;&nbsp;</a></span>isValidIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DenseElementsAttr::isValidIntOrFloat </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dataEltSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the information for a c++ data type, check if this type is valid for the current attribute. This method is used to verify specific type invariants that the templatized 'getValues' method cannot.</p>
<p>A method used to verify specific type invariants that the templatized 'get' method cannot. </p>

</div>
</div>
<a id="a71ba5d17627aea7a53baa138bb63d1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba5d17627aea7a53baa138bb63d1c9">&#9670;&nbsp;</a></span>mapValues() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::mapValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>newElementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APInt &amp;)&gt;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a new <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> by mapping each int value to a new underlying APInt. The new values can represent either a integer or float. This underlying type must be an <a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a>. </p>

</div>
</div>
<a id="a1f171c2c466569cb71f70004846ec478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f171c2c466569cb71f70004846ec478">&#9670;&nbsp;</a></span>mapValues() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::mapValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>newElementType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; APInt(const APFloat &amp;)&gt;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a new <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> by mapping each float value to a new underlying APInt. the new values can represent either a integer or float. This underlying type must be an <a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a>. </p>

</div>
</div>
<a id="a11fbc2ca37e1bbfa30550c0becd8edd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fbc2ca37e1bbfa30550c0becd8edd1">&#9670;&nbsp;</a></span>raw_int_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a> mlir::DenseElementsAttr::raw_int_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterators to the raw APInt values for each element in this attribute. </p>

</div>
</div>
<a id="a8777e4250a1fefb04eb82cfcfa5c9161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8777e4250a1fefb04eb82cfcfa5c9161">&#9670;&nbsp;</a></span>raw_int_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr_1_1IntElementIterator.html">IntElementIterator</a> mlir::DenseElementsAttr::raw_int_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac09e89266a795b6620886950bf0c6494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09e89266a795b6620886950bf0c6494">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> DenseElementsAttr::reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new <a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a> that has the same data as the current attribute, but has been reshaped to 'newType'. The new type must have the same total number of elements as well as element type. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="Attributes_8h_source.html">Attributes.h</a></li>
<li>lib/IR/<a class="el" href="Attributes_8cpp.html">Attributes.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
